<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Association Project - Multi-Tier Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 1.1em;
        }

        .tier-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            margin: 0 10px;
            font-size: 1.1em;
        }

        .tier-1 {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1e3c72;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .tier-2 {
            background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%);
            color: #1e3c72;
            box-shadow: 0 4px 15px rgba(192, 192, 192, 0.4);
        }

        .tier-3 {
            background: linear-gradient(135deg, #cd7f32 0%, #e9a76a 100%);
            color: #1e3c72;
            box-shadow: 0 4px 15px rgba(205, 127, 50, 0.4);
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px 0 rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px 0 rgba(102, 126, 234, 0.6);
        }
        
        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: linear-gradient(135deg, #ea4335 0%, #c62828 100%);
        }

        button.success {
            background: linear-gradient(135deg, #34a853 0%, #2e7d32 100%);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .info-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .info-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .info-card h3 {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 10px;
        }
        
        .info-card .value {
            font-size: 1.8em;
            font-weight: bold;
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .standings-container, .next-games-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: rgba(255, 255, 255, 0.2);
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        tr.user-team {
            background: rgba(102, 126, 234, 0.3);
            font-weight: bold;
        }
        
        tr.promotion-zone {
            background: rgba(52, 168, 83, 0.3);
        }

        tr.playoff-zone {
            background: rgba(255, 193, 7, 0.2);
        }
        
        tr.auto-relegate {
            background: rgba(234, 67, 53, 0.3);
        }
        
        .game-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .team {
            flex: 1;
            font-weight: 600;
        }
        
        .vs {
            padding: 0 15px;
            opacity: 0.7;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 15px;
            padding: 40px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }

        .team-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .team-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .team-card:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .team-card h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .team-card p {
            opacity: 0.9;
            font-size: 0.95em;
            margin: 5px 0;
        }

        .playoff-bracket {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
        }

        .bracket-round {
            display: grid;
            gap: 20px;
            margin-bottom: 30px;
        }

        .bracket-match {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .bracket-team {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bracket-team.winner {
            background: rgba(52, 168, 83, 0.3);
            font-weight: bold;
        }

        .bracket-team.loser {
            opacity: 0.6;
        }

        .history-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
        }

        .history-item {
            display: grid;
            grid-template-columns: 1fr 1fr 1.5fr 1fr 1fr;
            gap: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 10px;
            align-items: center;
        }

        @media (max-width: 968px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
            
            .info-bar {
                grid-template-columns: repeat(2, 1fr);
            }

            .history-item {
                grid-template-columns: 1fr;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <!-- Team Selection Modal -->
    <div id="teamSelectionModal" class="modal">
        <div class="modal-content">
            <h1>üèÄ Welcome to The Association Project</h1>
            <p style="text-align: center; font-size: 1.2em; margin: 20px 0; opacity: 0.9;">
                Select your starting tier and team to begin your journey
            </p>

            <div style="text-align: center; margin: 30px 0;">
                <h2>Choose Your Starting Tier</h2>
                <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                    <button onclick="selectTier(1)" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                        Start in Tier 1 (Premier League)
                    </button>
                    <button onclick="selectTier(2)" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                        Start in Tier 2 (Regional League)
                    </button>
                    <button onclick="selectTier(3)" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                        Start in Tier 3 (Metro League)
                    </button>
                </div>
            </div>

            <div id="tier1Teams" class="team-grid" style="display: none;">
                <!-- Populated by JavaScript -->
            </div>

            <div id="tier2Teams" class="team-grid" style="display: none;">
                <!-- Populated by JavaScript -->
            </div>
            
            <div id="tier3Teams" class="team-grid" style="display: none;">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Season End Modal -->
    <div id="seasonEndModal" class="modal hidden">
        <div class="modal-content" id="seasonEndContent">
            <!-- Populated by JavaScript -->
        </div>
    </div>

    <!-- Playoff Modal -->
    <div id="playoffModal" class="modal hidden">
        <div class="modal-content" id="playoffContent">
            <!-- Populated by JavaScript -->
        </div>
    </div>

    <!-- Roster Management Modal -->
    <div id="rosterModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1600px;">
            <h1 style="text-align: center; margin-bottom: 30px;">üìã Roster Management</h1>
            
            <!-- Position Breakdown -->
            <div id="positionBreakdown"></div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                <!-- Your Roster -->
                <div>
                    <h2 style="margin-bottom: 20px;">Your Roster (<span id="rosterCount">0</span>/15)</h2>
                    
                    <!-- Salary Cap Status -->
                    <div id="capStatus"></div>
                    
                    <div id="currentRoster" style="max-height: 500px; overflow-y: auto;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Free Agents -->
                <div>
                    <h2 style="margin-bottom: 20px;">Free Agents</h2>
                    
                    <!-- Filter Controls -->
                    <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <select id="positionFilter" onchange="filterFreeAgents()" style="padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="ALL" style="background: #1a1a1a; color: white;">All Positions</option>
                            <option value="PG" style="background: #1a1a1a; color: white;">PG</option>
                            <option value="SG" style="background: #1a1a1a; color: white;">SG</option>
                            <option value="SF" style="background: #1a1a1a; color: white;">SF</option>
                            <option value="PF" style="background: #1a1a1a; color: white;">PF</option>
                            <option value="C" style="background: #1a1a1a; color: white;">C</option>
                        </select>
                        
                        <select id="tierFilter" onchange="filterFreeAgents()" style="padding: 8px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="ALL" style="background: #1a1a1a; color: white;">All Tiers</option>
                            <option value="1" style="background: #1a1a1a; color: white;">Tier 1 (70-95)</option>
                            <option value="2" style="background: #1a1a1a; color: white;">Tier 2 (60-85)</option>
                            <option value="3" style="background: #1a1a1a; color: white;">Tier 3 (50-75)</option>
                        </select>

                        <button onclick="sortFreeAgents('rating')" style="padding: 8px 15px; font-size: 0.9em;">Sort by Rating</button>
                        <button onclick="sortFreeAgents('age')" style="padding: 8px 15px; font-size: 0.9em;">Sort by Age</button>
                    </div>
                    
                    <div id="freeAgentsList" style="max-height: 450px; overflow-y: auto;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button onclick="openTradeScreenFromRoster()" class="warning" style="font-size: 1.2em; padding: 15px 40px; margin-right: 15px;">
                    üìä Open Trade Screen
                </button>
                <button onclick="closeRosterManagementDynamic()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Done Managing Roster
                </button>
            </div>
        </div>
    </div>

    <!-- Player Development Summary Modal -->
    <div id="developmentModal" class="modal hidden">
        <div class="modal-content" style="max-width: 800px;">
            <h1 style="text-align: center; margin-bottom: 30px;">üåü Player Development Report</h1>
            
            <div id="developmentSummary" style="max-height: 500px; overflow-y: auto;">
                <!-- Populated by JavaScript -->
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button onclick="closeDevelopmentSummary()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Continue
                </button>
            </div>
        </div>
    </div>

    <!-- Free Agency Modal -->
    <div id="freeAgencyModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1800px;">
            <h1 style="text-align: center; margin-bottom: 20px;">ü§ù Free Agency Period</h1>
            <p style="text-align: center; font-size: 1.1em; margin-bottom: 10px;">
                Select players to make offers to. 
                <span style="font-weight: bold; color: #34a853;">Cap Space: <span id="faCapSpace">$0M</span></span>
            </p>
            <div id="faOfferTally" style="text-align: center; margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; display: none;">
                <span style="opacity: 0.8;">Selected: </span>
                <span id="faOfferCount" style="font-weight: bold;">0</span> player(s) ¬∑ 
                <span style="opacity: 0.8;">Est. Cost: </span>
                <span id="faOfferTotal" style="font-weight: bold; color: #fbbc04;">$0M</span> ¬∑ 
                <span style="opacity: 0.8;">Remaining: </span>
                <span id="faOfferRemaining" style="font-weight: bold;">$0M</span>
            </div>
            <p style="text-align: center; opacity: 0.8; margin-bottom: 30px; font-size: 0.95em;">
                You'll compete with other teams for these players. Higher offers and team success increase your chances.
            </p>
            
            <!-- Two column layout: Current Roster | Free Agents -->
            <div style="display: grid; grid-template-columns: 350px 1fr; gap: 20px; margin-bottom: 30px;">
                <!-- Current Roster Column -->
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 20px;">
                    <h2 style="margin-bottom: 15px; text-align: center;">üìã Current Roster</h2>
                    <div id="faCurrentRoster" style="max-height: 500px; overflow-y: auto;">
                        <!-- Current roster populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Free Agents Column -->
                <div>
                    <!-- Position Filter -->
                    <div style="margin-bottom: 15px; text-align: center;">
                        <label style="margin-right: 10px; font-weight: bold;">Filter by Position:</label>
                        <select id="faPositionFilter" onchange="filterFreeAgentsByPosition()" style="padding: 8px 15px; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); font-size: 1em; cursor: pointer;">
                            <option value="ALL" style="background: #1a1a1a;">All Positions</option>
                            <option value="PG" style="background: #1a1a1a;">Point Guard (PG)</option>
                            <option value="SG" style="background: #1a1a1a;">Shooting Guard (SG)</option>
                            <option value="SF" style="background: #1a1a1a;">Small Forward (SF)</option>
                            <option value="PF" style="background: #1a1a1a;">Power Forward (PF)</option>
                            <option value="C" style="background: #1a1a1a;">Center (C)</option>
                        </select>
                    </div>
                    
                    <div id="freeAgencyPlayersList" style="max-height: 500px; overflow-y: auto;">
                        <!-- Table of free agents populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div id="selectedOffersPanel" style="display: none; margin-bottom: 20px;">
                <h2 style="margin-bottom: 20px;">üìù Your Offers (<span id="offerCount">0</span>)</h2>
                <div id="offersList" style="max-height: 300px; overflow-y: auto;">
                    <!-- Selected players with offer inputs -->
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button id="submitOffersBtn" onclick="submitFreeAgencyOffers()" class="success" style="font-size: 1.2em; padding: 15px 40px;" disabled>
                    Submit Offers
                </button>
                <button onclick="skipFreeAgency()" style="font-size: 1.2em; padding: 15px 40px; margin-left: 15px;">
                    Skip Free Agency
                </button>
            </div>
        </div>
    </div>

    <!-- Free Agency Results Modal -->
    <div id="freeAgencyResultsModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1000px;">
            <h1 style="text-align: center; margin-bottom: 30px;">üìä Free Agency Results</h1>
            
            <div id="freeAgencyResultsContent" style="max-height: 500px; overflow-y: auto;">
                <!-- Results populated by JavaScript -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="continueFreeAgency()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Continue to Season Setup
                </button>
            </div>
        </div>
    </div>

    <!-- Finance Dashboard Modal -->
    <div id="financeDashboardModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1100px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h1 style="margin: 0;">üí∞ Club Finances</h1>
                <button id="financeDashboardCloseBtn" onclick="document.getElementById('financeDashboardModal').classList.add('hidden')" style="padding: 8px 20px;">‚úï Close</button>
            </div>
            <div id="financeDashboardContent" style="max-height: 600px; overflow-y: auto;">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Financial Transition Briefing Modal -->
    <div id="financialTransitionModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1000px;">
            <div id="financialTransitionContent">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- College Graduate Free Agency Modal -->
    <div id="collegeGradFAModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1100px;">
            <h1 style="text-align: center; margin-bottom: 10px;">üéì College Graduate Free Agency</h1>
            <p id="collegeGradSubtitle" style="text-align: center; font-size: 1.05em; margin-bottom: 5px; opacity: 0.9;"></p>
            <div id="collegeGradCapInfo" style="text-align: center; margin-bottom: 5px;"></div>
            <div id="collegeGradTally" style="text-align: center; margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; display: none;">
                <span style="opacity: 0.8;">Selected: </span>
                <span id="cgOfferCount" style="font-weight: bold;">0</span> player(s) ¬∑ 
                <span style="opacity: 0.8;">Est. Cost: </span>
                <span id="cgOfferTotal" style="font-weight: bold; color: #fbbc04;">$0M</span> ¬∑ 
                <span style="opacity: 0.8;">Remaining: </span>
                <span id="cgOfferRemaining" style="font-weight: bold;">$0M</span>
            </div>
            <div style="margin-bottom: 15px; display: flex; gap: 15px; align-items: center; justify-content: center;">
                <label>Position: 
                    <select id="cgPositionFilter" onchange="filterCollegeGrads()" style="padding: 6px;">
                        <option value="ALL">All</option>
                        <option value="PG">PG</option>
                        <option value="SG">SG</option>
                        <option value="SF">SF</option>
                        <option value="PF">PF</option>
                        <option value="C">C</option>
                    </select>
                </label>
                <label>Sort: 
                    <select id="cgSortBy" onchange="filterCollegeGrads()" style="padding: 6px;">
                        <option value="rating">Rating</option>
                        <option value="age">Age</option>
                        <option value="salary">Salary</option>
                        <option value="potential">Potential</option>
                    </select>
                </label>
            </div>
            <div id="collegeGradList" style="max-height: 450px; overflow-y: auto; margin-bottom: 20px;"></div>
            <div style="text-align: center; display: flex; gap: 15px; justify-content: center;">
                <button onclick="submitCollegeGradOffers()" id="cgSubmitBtn" class="success" style="font-size: 1.1em; padding: 12px 35px;" disabled>
                    üìù Submit Offers (<span id="cgSelectedCount">0</span>)
                </button>
                <button onclick="skipCollegeGradFA()" style="font-size: 1em; padding: 12px 25px; opacity: 0.8;">
                    Skip ‚Üí Continue
                </button>
            </div>
        </div>
    </div>

    <!-- Scouting Modal -->
    <div id="scoutingModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h1 style="margin: 0;">üîç Scouting Center</h1>
                <button onclick="closeScoutingModal()" style="font-size: 1.2em; padding: 8px 20px;">‚úï Close</button>
            </div>
            
            <!-- Tab Navigation -->
            <div style="display: flex; gap: 0; margin-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.15);">
                <button id="scoutTabScanner" onclick="switchScoutTab('scanner')" class="scout-tab active" style="padding: 12px 25px; border: none; background: rgba(102,126,234,0.3); color: white; font-size: 1em; cursor: pointer; border-radius: 8px 8px 0 0; border-bottom: 2px solid #667eea;">
                    üåê League Scanner
                </button>
                <button id="scoutTabPipeline" onclick="switchScoutTab('pipeline')" class="scout-tab" style="padding: 12px 25px; border: none; background: rgba(255,255,255,0.05); color: white; font-size: 1em; cursor: pointer; border-radius: 8px 8px 0 0; opacity: 0.7;">
                    üéì College Pipeline
                </button>
                <button id="scoutTabWatchlist" onclick="switchScoutTab('watchlist')" class="scout-tab" style="padding: 12px 25px; border: none; background: rgba(255,255,255,0.05); color: white; font-size: 1em; cursor: pointer; border-radius: 8px 8px 0 0; opacity: 0.7;">
                    ‚≠ê Watch List (<span id="watchlistCount">0</span>)
                </button>
                <button id="scoutTabNeeds" onclick="switchScoutTab('needs')" class="scout-tab" style="padding: 12px 25px; border: none; background: rgba(255,255,255,0.05); color: white; font-size: 1em; cursor: pointer; border-radius: 8px 8px 0 0; opacity: 0.7;">
                    üìä Team Needs
                </button>
            </div>
            
            <!-- Tab Content -->
            <div id="scoutTabContent" style="flex: 1; overflow-y: auto;"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div id="tradeModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1400px;">
            <h1 style="text-align: center; margin-bottom: 20px;">üìä Trade Players</h1>
            
            <!-- Position Breakdown -->
            <div id="tradePositionBreakdown"></div>
            
            <!-- Trade Partner Selection -->
            <div style="text-align: center; margin-bottom: 30px;">
                <label style="font-size: 1.1em; margin-right: 15px;">Trade with:</label>
                <select id="tradePartnerSelect" onchange="loadTradePartner()" style="padding: 10px; font-size: 1em; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); min-width: 300px;">
                    <option value="" style="background: #1a1a1a; color: white;">-- Select Team --</option>
                </select>
            </div>

            <div id="tradeInterface" style="display: none;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;">
                    <!-- Your Team Offers -->
                    <div>
                        <h2 style="margin-bottom: 20px; text-align: center;">You Give Up</h2>
                        
                        <!-- Players -->
                        <h3 style="margin: 15px 0 10px 0; font-size: 1em; opacity: 0.8;">Players:</h3>
                        <div id="yourTradeRoster" style="max-height: 300px; overflow-y: auto; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                        
                        <!-- Draft Picks (T1 only) -->
                        <h3 id="yourTradePicksHeader" style="margin: 20px 0 10px 0; font-size: 1em; opacity: 0.8;">Draft Picks:</h3>
                        <div id="yourTradePicks" style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- AI Team Offers -->
                    <div>
                        <h2 style="margin-bottom: 20px; text-align: center;">You Receive</h2>
                        
                        <!-- Players -->
                        <h3 style="margin: 15px 0 10px 0; font-size: 1em; opacity: 0.8;">Players:</h3>
                        <div id="aiTradeRoster" style="max-height: 300px; overflow-y: auto; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                        
                        <!-- Draft Picks (T1 only) -->
                        <h3 id="aiTradePicksHeader" style="margin: 20px 0 10px 0; font-size: 1em; opacity: 0.8;">Draft Picks:</h3>
                        <div id="aiTradePicks" style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Trade Summary -->
                <div id="tradeSummary" style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px; text-align: center;">Trade Summary</h3>
                    <div style="display: flex; justify-content: space-around; text-align: center;">
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8;">You Give</div>
                            <div id="tradeYourValue" style="font-size: 1.5em; font-weight: bold; margin-top: 5px;">0</div>
                            <div style="font-size: 0.9em; opacity: 0.8;">Total Rating</div>
                        </div>
                        <div style="display: flex; align-items: center; font-size: 2em;">‚ÜîÔ∏è</div>
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8;">You Receive</div>
                            <div id="tradeAiValue" style="font-size: 1.5em; font-weight: bold; margin-top: 5px;">0</div>
                            <div style="font-size: 0.9em; opacity: 0.8;">Total Rating</div>
                        </div>
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8;">Net Value</div>
                            <div id="tradeNetValue" style="font-size: 1.5em; font-weight: bold; margin-top: 5px;">0</div>
                            <div style="font-size: 0.9em; opacity: 0.8;">(+ = You Win)</div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="text-align: center; display: flex; gap: 20px; justify-content: center;">
                    <button onclick="proposeTrade()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                        Propose Trade
                    </button>
                    <button onclick="closeTradeScreen()" style="font-size: 1.2em; padding: 15px 40px;">
                        Cancel
                    </button>
                </div>
            </div>

            <div id="noTradePartner" style="text-align: center; padding: 40px; opacity: 0.7;">
                <p style="font-size: 1.2em;">Select a team to start trading</p>
            </div>
        </div>
    </div>

    <!-- AI Trade Proposal Modal -->
    <div id="aiTradeProposalModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1000px;">
            <h1 style="text-align: center; margin-bottom: 20px;">üì¨ Trade Offer Received!</h1>
            
            <div id="aiProposalTeam" style="text-align: center; margin-bottom: 25px; font-size: 1.2em;">
                <!-- Team name populated by JavaScript -->
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 25px;">
                <!-- You Give -->
                <div>
                    <h2 style="margin-bottom: 15px; text-align: center; color: #ea4335;">You Would Give Up</h2>
                    <div id="aiProposalYouGive" style="background: rgba(234,67,53,0.1); padding: 15px; border-radius: 8px; min-height: 150px;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- You Receive -->
                <div>
                    <h2 style="margin-bottom: 15px; text-align: center; color: #34a853;">You Would Receive</h2>
                    <div id="aiProposalYouReceive" style="background: rgba(52,168,83,0.1); padding: 15px; border-radius: 8px; min-height: 150px;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Proposal Summary -->
            <div id="aiProposalSummary" style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 8px; margin-bottom: 25px; text-align: center;">
                <!-- Populated by JavaScript -->
            </div>

            <!-- Action Buttons -->
            <div style="text-align: center; display: flex; gap: 20px; justify-content: center;">
                <button onclick="acceptAiTradeProposal()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    ‚úÖ Accept Trade
                </button>
                <button onclick="rejectAiTradeProposal()" class="danger" style="font-size: 1.2em; padding: 15px 40px;">
                    ‚ùå Decline Trade
                </button>
            </div>
        </div>
    </div>

    <!-- Draft Results Modal -->
    <div id="draftResultsModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1200px;">
            <h1 style="text-align: center; margin-bottom: 20px;">üéì Draft Results</h1>
            
            <div style="text-align: center; margin-bottom: 20px;">
                <button onclick="showDraftRound(1)" id="draftRound1Btn" class="success" style="margin: 0 5px; padding: 10px 20px;">Round 1</button>
                <button onclick="showDraftRound('Comp')" id="draftCompBtn" style="margin: 0 5px; padding: 10px 20px;">Comp.</button>
                <button onclick="showDraftRound(2)" id="draftRound2Btn" style="margin: 0 5px; padding: 10px 20px;">Round 2</button>
                <button onclick="showUserDraftPicks()" id="userPicksBtn" style="margin: 0 5px; padding: 10px 20px; background: linear-gradient(135deg, #fbbc04 0%, #f9a825 100%);">Your Picks</button>
            </div>

            <div id="draftResultsContent" style="max-height: 500px; overflow-y: auto; padding: 20px;">
                <!-- Populated by JavaScript -->
            </div>

            <div style="text-align: center; margin-top: 25px;">
                <button onclick="closeDraftResults()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Continue to Free Agency
                </button>
            </div>
        </div>
    </div>

    <!-- Championship Playoff Modal -->
    <div id="championshipPlayoffModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1200px;">
            <div id="championshipPlayoffContent">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Draft Lottery Modal -->
    <div id="lotteryModal" class="modal hidden">
        <div class="modal-content" style="max-width: 900px;">
            <h1 style="text-align: center; margin-bottom: 20px;">üé∞ Draft Lottery Results</h1>
            
            <div id="lotteryContent" style="max-height: 500px; overflow-y: auto; padding: 20px;">
                <!-- Populated by JavaScript -->
            </div>

            <div style="text-align: center; margin-top: 25px;">
                <button onclick="closeLotteryModal()" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Continue to Draft
                </button>
            </div>
        </div>
    </div>

    <!-- User Draft Pick Modal -->
    <div id="userDraftPickModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1600px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h1 style="margin: 0;">üéØ Your Pick</h1>
                <div style="text-align: right;">
                    <div id="userPickNumber" style="font-size: 1.5em; font-weight: bold; color: #fbbc04;"></div>
                    <div style="opacity: 0.7; margin-top: 5px;">Make your selection</div>
                </div>
            </div>

            <!-- Filter/Sort Controls -->
            <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: center;">
                <div>
                    <label style="margin-right: 8px;">Filter by Position:</label>
                    <select id="draftPositionFilter" onchange="filterDraftProspects()" style="padding: 8px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px;">
                        <option value="ALL" style="background: #1a1a1a; color: white;">All Positions</option>
                        <option value="PG" style="background: #1a1a1a; color: white;">PG</option>
                        <option value="SG" style="background: #1a1a1a; color: white;">SG</option>
                        <option value="SF" style="background: #1a1a1a; color: white;">SF</option>
                        <option value="PF" style="background: #1a1a1a; color: white;">PF</option>
                        <option value="C" style="background: #1a1a1a; color: white;">C</option>
                    </select>
                </div>
                <div>
                    <label style="margin-right: 8px;">Sort by:</label>
                    <select id="draftSortBy" onchange="filterDraftProspects()" style="padding: 8px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px;">
                        <option value="rating" style="background: #1a1a1a; color: white;">Rating (High to Low)</option>
                        <option value="age" style="background: #1a1a1a; color: white;">Age (Young to Old)</option>
                        <option value="position" style="background: #1a1a1a; color: white;">Position</option>
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 400px; gap: 20px;">
                <!-- Available Prospects (Left) -->
                <div>
                    <h2 style="margin-bottom: 15px;">Available Prospects</h2>
                    <div id="draftProspectsList" style="max-height: 500px; overflow-y: auto; background: rgba(255,255,255,0.03); padding: 15px; border-radius: 8px;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <!-- Your Current Roster (Right) -->
                <div>
                    <h2 style="margin-bottom: 15px;">Your Roster</h2>
                    <div id="draftYourRoster" style="max-height: 500px; overflow-y: auto; background: rgba(251,188,4,0.1); padding: 15px; border-radius: 8px;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="gameContainer" class="container" style="display: none;">
        <h1>üèÄ The Association Project</h1>
        <p class="subtitle">
            <span class="tier-badge" id="tierBadge">TIER 1</span>
            <span id="leagueName">North American Premier League</span>
        </p>

        <div class="info-bar">
            <div class="info-card">
                <h3>Season</h3>
                <div class="value" id="currentSeason">2025-26</div>
            </div>
            <div class="info-card">
                <h3>üìÖ Date</h3>
                <div class="value" id="currentDateDisplay" style="font-size: 1.1em;">-</div>
                <div id="calendarEvent" style="font-size: 0.8em; margin-top: 4px; color: #ffd700; display: none;"></div>
            </div>
            <div class="info-card">
                <h3>Your Team</h3>
                <div class="value" id="userTeamName">-</div>
            </div>
            <div class="info-card">
                <h3>Record</h3>
                <div class="value" id="userRecord">0-0</div>
            </div>
            <div class="info-card">
                <h3>Roster Strength</h3>
                <div class="value" id="rosterStrength">-</div>
            </div>
            <div class="info-card" style="cursor: pointer;" onclick="openFinanceDashboard()">
                <h3>üí∞ Budget</h3>
                <div class="value" id="budgetDisplay" style="font-size: 0.95em;">-</div>
                <div id="budgetSubDisplay" style="font-size: 0.75em; margin-top: 2px; opacity: 0.7;">-</div>
            </div>
            <div class="info-card" id="coachInfoCard" style="cursor: pointer;" onclick="openCoachManagement()">
                <h3>üéì Head Coach</h3>
                <div class="value" id="coachNameDisplay" style="font-size: 0.95em;">-</div>
                <div id="coachOverallDisplay" style="font-size: 0.8em; margin-top: 2px; opacity: 0.8;">-</div>
            </div>
            <div class="info-card">
                <h3>Games Played</h3>
                <div class="value"><span id="currentGame">0</span> / <span id="totalGames">82</span></div>
            </div>
        </div>

        <div class="controls">
            <button onclick="simNextGame()" id="simNextBtn">‚ñ∂Ô∏è Sim Next Game</button>
            <button onclick="watchNextGame()" id="watchNextBtn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üëÅÔ∏è Watch Game</button>
            <button onclick="simDay()" id="simDayBtn">üìÖ Sim Day</button>
            <button onclick="simWeek()" id="simWeekBtn">‚è© Sim Week</button>
            <button onclick="finishSeason()" id="finishBtn">‚è≠Ô∏è Finish Season</button>
            <button onclick="openRosterManagementHub()" id="rosterBtn" style="background: linear-gradient(135deg, #34a853 0%, #2d8f47 100%);">üë• Roster Management</button>
            <button onclick="openCalendarView()" id="calendarBtn" style="background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);">üìÖ Calendar</button>
            <button onclick="openFinanceDashboard()" id="financeBtn" style="background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);">üí∞ Finances</button>
            <button onclick="openScoutingModal()" id="scoutingBtn" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">üîç Scouting</button>
            <button onclick="openFranchiseHistory()" id="historyBtn" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">üìú History</button>
            <button onclick="resetGame()" class="danger">üîÑ Reset Game</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: rgba(102, 126, 234, 0.3);"></div>
                <span>Your Team</span>
            </div>
            <div class="legend-item" id="promotionLegend" style="display: none;">
                <div class="legend-box" style="background: rgba(52, 168, 83, 0.3);"></div>
                <span>Auto-Promotion</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: rgba(255, 193, 7, 0.2);"></div>
                <span id="playoffLegendText">Playoff Zone</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: rgba(234, 67, 53, 0.3);"></div>
                <span id="autoZoneLegendText">Auto-Relegation</span>
            </div>
        </div>

        <div class="content-grid">
            <div class="standings-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 id="standingsTitle" style="margin: 0;">League Standings</h2>
                    <div style="display: flex; gap: 10px;">
                        <button id="viewOverallBtn" onclick="toggleStandingsView('overall')" style="padding: 8px 16px; font-size: 0.9em; background: linear-gradient(135deg, #667eea 0%, #5568d3 100%);">
                            Overall
                        </button>
                        <button id="viewDivisionBtn" onclick="toggleStandingsView('division')" style="padding: 8px 16px; font-size: 0.9em;">
                            Division
                        </button>
                        <span style="border-left: 2px solid rgba(255,255,255,0.2); margin: 0 5px;"></span>
                        <button id="viewTier1Btn" onclick="viewTierStandings(1)" style="padding: 8px 16px; font-size: 0.9em;">
                            View Tier 1
                        </button>
                        <button id="viewTier2Btn" onclick="viewTierStandings(2)" style="padding: 8px 16px; font-size: 0.9em;">
                            View Tier 2
                        </button>
                        <button id="viewTier3Btn" onclick="viewTierStandings(3)" style="padding: 8px 16px; font-size: 0.9em;">
                            View Tier 3
                        </button>
                        <button id="viewCurrentBtn" onclick="viewTierStandings(gameState.currentTier)" style="padding: 8px 16px; font-size: 0.9em; background: linear-gradient(135deg, #34a853 0%, #2e7d32 100%);">
                            My Tier
                        </button>
                    </div>
                </div>
                <div id="standingsLeagueInfo" style="text-align: center; margin-bottom: 10px; font-size: 0.9em; opacity: 0.8;">
                    <!-- Shows which tier is being viewed -->
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Team</th>
                            <th>Division</th>
                            <th>W</th>
                            <th>L</th>
                            <th>PCT</th>
                            <th>DIFF</th>
                        </tr>
                    </thead>
                    <tbody id="standingsBody">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
            </div>

            <div class="next-games-container">
                <h2>üìÖ Upcoming Schedule</h2>
                <div id="todaysGamesContainer" style="margin-bottom: 15px;">
                    <!-- Today's games across all tiers -->
                </div>
                <div id="nextGamesContainer">
                    <!-- Upcoming user team games -->
                </div>
            </div>
        </div>

        <div id="seasonHistory" class="history-section" style="display: none;">
            <h2>üèÜ Career History</h2>
            <div id="historyList">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Watch Game Modal -->
    <div id="watchGameModal" class="modal hidden" style="z-index: 1020;">
        <div class="modal-content" style="max-width: 1000px; max-height: 95vh; overflow: hidden; padding: 0;">
            <div id="watchGameContent"></div>
        </div>
    </div>

    <!-- Post-Game Summary Modal -->
    <div id="postGameModal" class="modal hidden">
        <div class="modal-content" style="max-width: 700px;">
            <div id="postGameContent"></div>
            <div style="text-align: center; margin-top: 15px;">
                <button onclick="document.getElementById('postGameModal').classList.add('hidden')" class="success" style="font-size: 1.1em; padding: 12px 35px;">Continue</button>
            </div>
        </div>
    </div>

    <!-- Box Score Modal (detailed view from calendar) -->
    <div id="boxScoreModal" class="modal hidden" style="z-index: 1010;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <div id="boxScoreContent"></div>
            <div style="text-align: center; margin-top: 15px;">
                <button onclick="document.getElementById('boxScoreModal').classList.add('hidden')" class="success" style="padding: 10px 30px;">Close</button>
            </div>
        </div>
    </div>

    <!-- Franchise History Modal -->
    <div id="franchiseHistoryModal" class="modal hidden">
        <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">
            <h2 style="text-align: center; margin-bottom: 20px;">üìú Franchise History</h2>
            <div id="franchiseHistoryContent">
                <!-- Populated by JavaScript -->
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="document.getElementById('franchiseHistoryModal').classList.add('hidden')" class="success" style="font-size: 1.1em; padding: 12px 35px;">Close</button>
            </div>
        </div>
    </div>

    <!-- Roster Compliance Modal -->
    <div id="complianceModal" class="modal hidden">
        <div class="modal-content" style="max-width: 800px;">
            <div id="complianceModalContent">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Injury Report Modal -->
    <div id="injuryModal" class="modal hidden">
        <div class="modal-content" style="max-width: 700px;">
            <h2 style="text-align: center; color: #ea4335; margin-bottom: 20px;">üöë Injury Report</h2>
            
            <div id="injuryDetails" style="background: rgba(234,67,53,0.1); padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid rgba(234,67,53,0.3);">
                <!-- Populated by JavaScript -->
            </div>
            
            <div id="injuryOptions" style="margin-bottom: 20px;">
                <!-- Populated by JavaScript -->
            </div>
            
            <div style="text-align: center;">
                <button id="injuryConfirmBtn" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Confirm Decision
                </button>
            </div>
        </div>
    </div>

    <!-- Coach Management Modal -->
    <div id="coachModal" class="modal hidden">
        <div class="modal-content" id="coachModalContent" style="max-width: 1100px; width: 95%;">
            <!-- Populated by JavaScript -->
        </div>
    </div>

    <!-- Calendar View Modal -->
    <div id="calendarModal" class="modal hidden">
        <div class="modal-content" id="calendarContent" style="max-width: 1100px; width: 95%;">
        </div>
    </div>
    
    <!-- All-Star Game Modal -->
    <div id="allStarModal" class="modal hidden">
        <div class="modal-content" id="allStarContent" style="max-width: 1000px; width: 95%;">
        </div>
    </div>

    <!-- Contract Decisions Modal -->
    <div id="contractDecisionsModal" class="modal hidden">
        <div class="modal-content" style="max-width: 900px;">
            <h2 style="text-align: center; margin-bottom: 10px;">üìù Contract Decisions</h2>
            <p style="text-align: center; opacity: 0.8; margin-bottom: 25px;">
                The following players' contracts have expired. Decide who to re-sign before they hit free agency.
            </p>
            
            <div id="contractDecisionsSummary" style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <!-- Summary info populated by JavaScript -->
            </div>
            
            <div id="expiringContractsList" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Player cards populated by JavaScript -->
            </div>
            
            <div style="text-align: center; padding-top: 15px; border-top: 2px solid rgba(255,255,255,0.1);">
                <button id="contractDecisionsConfirmBtn" class="success" style="font-size: 1.2em; padding: 15px 40px;">
                    Confirm Decisions
                </button>
            </div>
        </div>
    </div>

    <!-- Module imports ‚Äî loads extracted engines and exposes them globally -->
    <script type="module">
        import { PlayerAttributes } from './src/engines/PlayerAttributes.js';
        import { CoachEngine } from './src/engines/CoachEngine.js';
        import { GameState } from './src/engines/GameState.js';
        import { FinanceEngine, METRO_POPULATIONS, getMetroPopulation, populationToMarketSize } from './src/engines/FinanceEngine.js';
        import { GameEngine } from './src/engines/GameEngine.js';
        import { SimulationController } from './src/engines/SimulationController.js';
        import { CalendarEngine } from './src/engines/CalendarEngine.js';
        import { EventBus, GameEvents, eventBus } from './src/engines/EventBus.js';
        import { StorageEngine } from './src/engines/StorageEngine.js';
        import { UIRenderer } from './src/engines/UIRenderer.js';
        import { OffseasonController } from './src/engines/OffseasonController.js';
        import { TradeController } from './src/engines/TradeController.js';
        import { DraftController } from './src/engines/DraftController.js';
        import { GameSimController } from './src/engines/GameSimController.js';
        import { FinanceController } from './src/engines/FinanceController.js';
        import { RosterController } from './src/engines/RosterController.js';
        import { GamePipeline } from './src/engines/GamePipeline.js';
        import { ChemistryEngine } from './src/engines/ChemistryEngine.js';
        import { InjuryEngine } from './src/engines/InjuryEngine.js';
        import { FatigueEngine } from './src/engines/FatigueEngine.js';
        import { SalaryCapEngine } from './src/engines/SalaryCapEngine.js';
        import { PlayerDevelopmentEngine } from './src/engines/PlayerDevelopmentEngine.js';
        import { LeagueManager } from './src/engines/LeagueManager.js';
        import { DivisionManager, CITY_TO_DIVISIONS as _CTD } from './src/engines/DivisionManager.js';
        import { StatEngine } from './src/engines/StatEngine.js';
        import { TeamFactory } from './src/engines/TeamFactory.js';
        import { DraftEngine } from './src/engines/DraftEngine.js';
        import { TradeEngine } from './src/engines/TradeEngine.js';
        import { FreeAgencyEngine } from './src/engines/FreeAgencyEngine.js';
        import { PlayoffEngine } from './src/engines/PlayoffEngine.js';
        import { GMMode } from './src/engines/GMMode.js';
        import { ScoutingEngine } from './src/engines/ScoutingEngine.js';
        import { OwnerEngine } from './src/engines/OwnerEngine.js';
        import { UIHelpers } from './src/engines/UIHelpers.js';

        console.log('üèÄ Modules loaded: PlayerAttributes, CoachEngine, GameState, FinanceEngine, GameEngine, SimulationController, CalendarEngine, EventBus, StorageEngine');

        // ‚îÄ‚îÄ‚îÄ Export all engines to window for non-module script access ‚îÄ‚îÄ‚îÄ
        Object.assign(window, {
            PlayerAttributes, CoachEngine, GameState, FinanceEngine, GameEngine,
            SimulationController, CalendarEngine, EventBus, GameEvents, eventBus,
            StorageEngine, UIRenderer, GamePipeline, ChemistryEngine, InjuryEngine,
            FatigueEngine, SalaryCapEngine, PlayerDevelopmentEngine, LeagueManager,
            DivisionManager, StatEngine, TeamFactory, DraftEngine, TradeEngine,
            FreeAgencyEngine, PlayoffEngine, GMMode, ScoutingEngine, OwnerEngine,
            UIHelpers, 
            METRO_POPULATIONS, _CTD,
            getFatiguePenalty: (fatigue) => FatigueEngine.getPenalty(fatigue),
            // Controllers
            OffseasonController, TradeController, DraftController,
            GameSimController, FinanceController, RosterController
        });

        // Initialize StorageEngine (async), then boot the game
        StorageEngine.init().then(() => {
            if (typeof window._initGame === 'function') window._initGame();
        });
    </script>

    <!-- Main game code ‚Äî wrapped in _initGame, called by module script after imports -->
    <script>
    window._initGame = function() {


        // ============================================
        // üèÄ REFACTORED ARCHITECTURE - INCREMENTAL APPROACH
        // ============================================
        // This section adds the new modular architecture while keeping
        // all existing code working. Nothing breaks!

        // ‚îÄ‚îÄ‚îÄ OffseasonController (lazy init) ‚îÄ‚îÄ‚îÄ
        let _offseasonController = null;
        function getOffseasonController() {
            if (!_offseasonController) {
                _offseasonController = new window.OffseasonController({
                    gameState, eventBus, GameEvents,
                    engines: { PlayoffEngine, CalendarEngine, CoachEngine, StatEngine, FinanceEngine, FreeAgencyEngine, StorageEngine, PlayerDevelopmentEngine, PlayerAttributes, TeamFactory, LeagueManager, SalaryCapEngine, DivisionManager },
                    helpers: {
                        getUserTeam, getTeamById, formatCurrency, getRatingColor,
                        getEffectiveCap, calculateTeamSalary, getRemainingCap, getSalaryCap,
                        generateSalary, determineContractLength, initializePlayerChemistry,
                        ensureRosterExists, assignDivision,
                        balanceTier1Divisions: () => DivisionManager.balanceTier1(gameState.tier1Teams),
                        balanceTier2Divisions: () => DivisionManager.balanceTier2(gameState.tier2Teams),
                        balanceTier3Divisions: () => DivisionManager.balanceTier3(gameState.tier3Teams),
                        sortTeamsByStandings,
                        simulatePlayoffBracket: (...args) => getGameSimController().simulatePlayoffBracket(...args),
                        applyParachutePayment: (...args) => SalaryCapEngine.applyParachutePayment(...args),
                        applyPromotionBonus: (...args) => SalaryCapEngine.applyPromotionBonus(...args),
                        getMarketValue,
                        getRetirementProbability: (...args) => PlayerDevelopmentEngine.getRetirementProbability(...args),
                        saveGameState, updateUI,
                        developTeamPlayers: (team, maxGames) => {
                            if (!gameState.retirementHistory) gameState.retirementHistory = [];
                            return PlayerDevelopmentEngine.developTeamPlayers(team, maxGames,
                                { PlayerAttributes, CoachEngine },
                                { retirementHistory: gameState.retirementHistory, currentSeason: gameState.currentSeason });
                        },
                        handleAITeamFreeAgency: (team, expiredPlayers) => {
                            return FreeAgencyEngine.handleAITeamFreeAgency(team, expiredPlayers, gameState.freeAgents, {
                                TeamFactory, getEffectiveCap, calculateTeamSalary
                            });
                        },
                        advanceFinancialTransitions,
                        healAllInjuries: (team) => InjuryEngine.healAllInjuries(team),
                        resetAllFatigue: (teams) => FatigueEngine.resetAll(teams),
                        clearMarketValueCache: (players) => TeamFactory.clearMarketValueCache(players),
                        runDraft: () => getDraftController().runDraft(),
                        startCollegeGraduateFA: () => getDraftController().startCollegeGraduateFA(),
                        showFreeAgencyModal,
                        generateSponsorOffers: (team) => OwnerEngine.generateSponsorOffers(team),
                        applyAIFinancialDefaults: (team) => OwnerEngine.applyAIFinancialDefaults(team),
                        showOwnerModeModal: (team) => getFinanceController().showOwnerModeModal(team),
                        buildCurrentCoachHTML, calculateTeamChemistry,
                        getGameSimController: () => getGameSimController()
                    }
                });
            }
            return _offseasonController;
        }

        // ‚îÄ‚îÄ‚îÄ TradeController (lazy init) ‚îÄ‚îÄ‚îÄ
        let _tradeController = null;
        function getTradeController() {
            if (!_tradeController) {
                _tradeController = new window.TradeController({
                    gameState, eventBus, GameEvents,
                    engines: { TradeEngine, DraftEngine, ChemistryEngine },
                    helpers: {
                        getUserTeam, getTeamById, getCurrentTeams, formatCurrency, getRatingColor,
                        getEffectiveCap, calculateTeamSalary, ensureRosterExists,
                        initializePlayerChemistry,
                        initializeDraftPickOwnership: () => {
                            if (!gameState.draftPickOwnership) gameState.draftPickOwnership = {};
                            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
                            DraftEngine.initializePickOwnership(gameState.draftPickOwnership, allTeams, gameState.currentSeason);
                        },
                        getPickOwner: (originalTeamId, year, round) => {
                            if (!gameState.draftPickOwnership) gameState.draftPickOwnership = {};
                            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
                            DraftEngine.initializePickOwnership(gameState.draftPickOwnership, allTeams, gameState.currentSeason);
                            return DraftEngine.getPickOwner(gameState.draftPickOwnership, originalTeamId, year, round);
                        },
                        violatesStepienRule: (teamId, year, round) => {
                            if (!gameState.draftPickOwnership) gameState.draftPickOwnership = {};
                            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
                            DraftEngine.initializePickOwnership(gameState.draftPickOwnership, allTeams, gameState.currentSeason);
                            return DraftEngine.violatesStepienRule(gameState.draftPickOwnership, teamId, year, round);
                        },
                        calculatePickValue: (year, round, originalTeamRecord) => {
                            return DraftEngine.calculatePickValue(year, round, gameState.currentSeason, originalTeamRecord);
                        },
                        tradeDraftPick: (fromTeamId, toTeamId, originalTeamId, year, round) => {
                            if (!gameState.draftPickOwnership) gameState.draftPickOwnership = {};
                            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
                            DraftEngine.initializePickOwnership(gameState.draftPickOwnership, allTeams, gameState.currentSeason);
                            DraftEngine.tradePick(gameState.draftPickOwnership, originalTeamId, toTeamId, year, round);
                        },
                        applyTradePenalty: (team, tradedPlayer) => ChemistryEngine.applyTradePenalty(team, tradedPlayer),
                        generatePositionBreakdownHTML, updateUI
                    },
                    simulationController
                });
            }
            return _tradeController;
        }

        // ‚îÄ‚îÄ‚îÄ DraftController (lazy init) ‚îÄ‚îÄ‚îÄ
        let _draftController = null;
        function getDraftController() {
            if (!_draftController) {
                _draftController = new window.DraftController({
                    gameState, eventBus, GameEvents,
                    engines: { DraftEngine, TeamFactory, PlayerAttributes, SalaryCapEngine, FreeAgencyEngine },
                    helpers: {
                        getUserTeam, getTeamById, formatCurrency, getRatingColor,
                        getEffectiveCap, calculateTeamSalary, getRemainingCap,
                        ensureRosterExists, initializePlayerChemistry,
                        getPickOwner: (originalTeamId, year, round) => {
                            if (!gameState.draftPickOwnership) gameState.draftPickOwnership = {};
                            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
                            DraftEngine.initializePickOwnership(gameState.draftPickOwnership, allTeams, gameState.currentSeason);
                            return DraftEngine.getPickOwner(gameState.draftPickOwnership, originalTeamId, year, round);
                        },
                        determineContractLength, generateSalary,
                        saveGameState,
                        proceedToPlayerDevelopment: () => getOffseasonController().proceedToPlayerDevelopment()
                    }
                });
            }
            return _draftController;
        }

        // ‚îÄ‚îÄ‚îÄ GameSimController (lazy init) ‚îÄ‚îÄ‚îÄ
        let _gameSimController = null;
        function getGameSimController() {
            if (!_gameSimController) {
                _gameSimController = new window.GameSimController({
                    gameState, eventBus, GameEvents,
                    engines: { CalendarEngine, GamePipeline, StatEngine, StorageEngine },
                    helpers: {
                        getUserTeam, getCurrentTeams, sortTeamsByStandings,
                        sortTeamsWithTiebreakers: (...args) => LeagueManager.sortTeamsWithTiebreakers(...args),
                        getRatingColor, formatCurrency, getRankSuffix, saveGameState, updateUI,
                        applyFatigueAutoRest: (team, isPlayoffs) => FatigueEngine.applyAutoRest(team, isPlayoffs),
                        processFatigueAfterGame: (...args) => FatigueEngine.processAfterGame(...args),
                        updateInjuries: (team) => InjuryEngine.updateInjuries(team),
                        checkForInjuries: (...args) => InjuryEngine.checkForInjuries(...args),
                        applyInjury, showNextInjuryModal,
                        runAllStarWeekend, simulatePlayoffSeries,
                        applyChampionshipBonus: (team) => ChemistryEngine.applyChampionshipBonus(team),
                        executePromotionRelegationFromResults: () => getOffseasonController().executePromotionRelegationFromResults(gameState.postseasonResults),
                        getOffseasonController: () => getOffseasonController(),
                        proceedToDraftOrDevelopment: () => getOffseasonController().proceedToDraftOrDevelopment(),
                        generateSchedule, simulateGame,
                        getGmMode: () => gmMode,
                        getSimulationController: () => simulationController
                    }
                });
            }
            return _gameSimController;
        }

        // ‚îÄ‚îÄ‚îÄ FinanceController (lazy init) ‚îÄ‚îÄ‚îÄ
        let _financeController = null;
        function getFinanceController() {
            if (!_financeController) {
                _financeController = new window.FinanceController({
                    gameState, eventBus, GameEvents,
                    engines: { FinanceEngine },
                    helpers: {
                        getUserTeam, formatCurrency, calculateTeamSalary, saveGameState,
                        proceedToDraftOrDevelopment: () => getOffseasonController().proceedToDraftOrDevelopment()
                    }
                });
            }
            return _financeController;
        }

        // ‚îÄ‚îÄ‚îÄ RosterController (lazy init) ‚îÄ‚îÄ‚îÄ
        let _rosterController = null;
        function getRosterController() {
            if (!_rosterController) {
                _rosterController = new window.RosterController({
                    gameState, eventBus, GameEvents,
                    engines: { FinanceEngine, PlayerAttributes, TeamFactory },
                    helpers: {
                        getUserTeam, formatCurrency, calculateTeamSalary, saveGameState,
                        ensureRosterExists, generatePositionBreakdownHTML,
                        getEffectiveCap, getSalaryCap, getRemainingCap, isUnderCap,
                        calculateTeamChemistry, getChemistryColor, getChemistryDescription,
                        getFatigueColor, getFatigueDescription, getRatingColor, gradeColor,
                        applyDropPenalty, initializePlayerChemistry, generateSalary,
                        displayFreeAgents, getAllLeaguePlayers, calculateTeamFit,
                        applyInjury,
                        eventBus, GameEvents
                    }
                });
            }
            return _rosterController;
        }
        
// ============================================
// GameEngine ‚Üí Extracted to src/engines/GameEngine.js
// ============================================


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STAT GENERATION ENGINE v1.0
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Pure function module: Takes two teams, returns player stat lines and game scores.
// No side effects. No state mutation. No UI.
//
// Architecture notes:
// - This replaces the old calculateGameOutcome's score generation with a bottom-up
//   player-stats-first approach. Individual performances produce the team score.
// - Designed for GM Mode accumulation now, Coach Mode game logs later.
// - Player traits/sub-archetypes have injection points but default to position base.
// - All randomness uses Math.random() ‚Äî can be swapped for seeded RNG later.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ============================================
// SimulationController ‚Üí Extracted to src/engines/SimulationController.js
// ============================================

// ============================================
// GLOBAL INSTANCE
// ============================================
const simulationController = new SimulationController();

// ============================================
// ============================================
// CalendarEngine ‚Üí Extracted to src/engines/CalendarEngine.js
// ============================================

// ============================================
// PLAYOFF ENGINE
// ============================================
// Manages playoff bracket generation, simulation, and calendar scheduling
// for all three tiers plus relegation brackets

// ============================================
// PLAYER ATTRIBUTES ENGINE
// ============================================
// Physical measurables + skill attributes that define each player.
// Rating is derived as a weighted composite of attributes by position.


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PlayerAttributes, CoachEngine, GameState
        // ‚Üí Extracted to src/engines/*.js modules
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PlayoffEngine ‚Äî extracted to src/engines/PlayoffEngine.js (Phase 3A)
    

        // GMMode ‚Äî extracted to src/engines/GMMode.js (Phase 3B)

// ============================================
// GLOBAL INSTANCE
// ============================================
// Will be created during initialization
let gmMode = null;

        
        // ============================================
        // PHASE 3: MIGRATION COMPATIBILITY LAYER
        // ============================================
        
        /**
         * Create GameState instance from old gameState object
         * This allows gradual migration from old code to new
         */
        function migrateToGameStateClass(oldGameState) {
            const newState = new GameState();
            
            // Copy all properties
            newState._currentSeason = oldGameState.currentSeason;
            newState._currentTier = oldGameState.currentTier;
            newState._userTeamId = oldGameState.userTeamId;
            newState._currentGame = oldGameState.currentGame || 0;
            newState._tier1Teams = oldGameState.tier1Teams;
            newState._tier2Teams = oldGameState.tier2Teams;
            newState._tier3Teams = oldGameState.tier3Teams;
            newState._schedule = oldGameState.schedule;
            newState._tier1Schedule = oldGameState.tier1Schedule || [];
            newState._tier2Schedule = oldGameState.tier2Schedule || [];
            newState._tier3Schedule = oldGameState.tier3Schedule || [];
            newState._draftPickOwnership = oldGameState.draftPickOwnership || {};
            newState._promotedToT1 = oldGameState.promotedToT1 || [];
            newState._relegatedFromT1 = oldGameState.relegatedFromT1 || [];
            newState._freeAgents = oldGameState.freeAgents || [];
            newState._pendingTradeProposal = oldGameState.pendingTradeProposal || null;
            newState._seasonHistory = oldGameState.seasonHistory || [];
            newState._championshipHistory = oldGameState.championshipHistory || [];
            newState._fullSeasonHistory = oldGameState.fullSeasonHistory || [];
            
            return newState;
        }
        
        /**
         * Backward compatibility: Keep global gameState working
         * This proxy makes old code work while using new GameState class
         */
        function createGameStateProxy(gameStateInstance) {
            return new Proxy(gameStateInstance, {
                get(target, prop) {
                    // Direct property access
                    if (prop in target) {
                        return target[prop];
                    }
                    
                    // Try getter
                    const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(target), prop);
                    if (descriptor && descriptor.get) {
                        return descriptor.get.call(target);
                    }
                    
                    // Try method
                    if (typeof target[prop] === 'function') {
                        return target[prop].bind(target);
                    }
                    
                    // Try private property (with underscore)
                    if (target['_' + prop] !== undefined) {
                        return target['_' + prop];
                    }
                    
                    return undefined;
                },
                
                set(target, prop, value) {
                    // Try setter
                    const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(target), prop);
                    if (descriptor && descriptor.set) {
                        descriptor.set.call(target, value);
                        return true;
                    }
                    
                    // Try private property
                    if (target['_' + prop] !== undefined) {
                        target['_' + prop] = value;
                        return true;
                    }
                    
                    // Direct set
                    target[prop] = value;
                    return true;
                }
            });
        }
        
// BACKWARD COMPATIBILITY WRAPPERS
// ============================================
// These functions maintain compatibility with existing code
// by wrapping the new architecture
        
        // Initialize GameState (Phase 3)
        function initializeGameState() {
            // Check if there's a saved game
            const savedData = localStorage.getItem('gbslSaveData');
            
            if (savedData) {
                try {
                    // Try to load as new GameState
                    const parsed = JSON.parse(savedData);
                    if (parsed.gameVersion && parseFloat(parsed.gameVersion) >= 4.0) {
                        // New format - deserialize directly
                        gameState = GameState.deserialize(savedData);
                    } else {
                        // Old format - migrate
                        const oldState = parsed;
                        const newState = migrateToGameStateClass(oldState);
                        gameState = createGameStateProxy(newState);
                    }
                    console.log('‚úÖ Game loaded from save');
                } catch (error) {
                    console.error('Load error, creating new game:', error);
                    gameState = createGameStateProxy(new GameState());
                }
            } else {
                // New game
                gameState = createGameStateProxy(new GameState());
            }
            
            return gameState;
        }
        
        let _oldGameState = {
            currentSeason: 2024,
            currentTier: 1,
            currentGame: 0,
            userTeamId: null,
            tier1Teams: [],
            tier2Teams: [],
            tier3Teams: [],
            schedule: [], // User's tier schedule
            tier1Schedule: [], // Tier 1 background schedule
            tier2Schedule: [], // Tier 2 background schedule
            tier3Schedule: [], // Tier 3 background schedule
            seasonHistory: [],
            viewingTier: null, // Track which tier's standings are being viewed (null = current tier)
            standingsView: 'overall', // 'overall' or 'division'
            freeAgents: [], // Pool of available free agents
            pendingTradeProposal: null, // AI-proposed trade waiting for user response
            lastAiTradeCheck: 0, // Game number when we last checked for AI trades
            promotedToT1: [], // Track teams promoted to Tier 1 (for compensatory picks)
            draftPickOwnership: {} // Track who owns which draft picks { teamId: { year: { round: ownerId } } }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FINANCE ENGINE ‚Äî Revenue-Based Economics
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // 
        // PHILOSOPHY: Tier 1 uses a hard salary cap (American franchise model
        // with shared TV revenue and enforced parity). Tiers 2 and 3 use
        // revenue-based spending limits (European model where financial
        // diversity IS the system). Each team's budget is derived from its
        // own revenue, which varies based on tier, franchise history, 
        // fanbase size, winning record, and legacy brand value.
        //
        // Revenue has 4 layers:
        //   1. League Revenue  ‚Äî TV deal, locked to current tier, changes instantly
        //   2. Matchday Revenue ‚Äî Gate/concessions, decays gradually with tier change
        //   3. Commercial Revenue ‚Äî Sponsors/partnerships, decays at medium rate
        //   4. Legacy/Brand Revenue ‚Äî Merch/licensing/history, very slow decay
        //
        // PHASE 1: Auto-calculated finances with visible Finance dashboard.
        //          Player can see all numbers. Owner Mode (interactive levers)
        //          planned for Phase 2.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // METRO POPULATION DATA ‚Äî drives market size for team finances
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Maps city names (extracted from team names) to metro area populations
        // in millions. Used to calculate market size multiplier for fanbase,
        // matchday revenue, and commercial revenue.
        //
        // Sources: US Census Bureau MSA estimates, Statistics Canada, INEGI Mexico
        // Population in millions (metro statistical area)

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // METRO_POPULATIONS + FinanceEngine
        // ‚Üí Extracted to src/engines/FinanceEngine.js module
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SALARY CAPS ‚Üí Delegated to SalaryCapEngine
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const SALARY_CAPS = SalaryCapEngine.SALARY_CAPS;
        const SALARY_FLOORS = SalaryCapEngine.SALARY_FLOORS;
        const PARACHUTE_PAYMENTS = SalaryCapEngine.PARACHUTE_PAYMENTS;
        const PROMOTION_BONUSES = SalaryCapEngine.PROMOTION_BONUSES;
        
        function advanceFinancialTransitions(allTeams) {
            SalaryCapEngine.advanceFinancialTransitions(allTeams);
        }

        // ========================================
        // TIEBREAKER SYSTEM ‚Üí Delegated to LeagueManager
        // ========================================
        
        // ========================================
        // TIEBREAKER SYSTEM (cont.) ‚Üí Delegated to LeagueManager
        // ========================================
        
        // ===== PLAYER DEVELOPMENT SYSTEM ‚Üí Delegated to PlayerDevelopmentEngine =====
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RETIREMENT PROBABILITY ‚Üí Delegated to PlayerDevelopmentEngine
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Apply development to all teams across all tiers
        // Handle AI team free agency decisions
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AI Signing Phase: All AI teams sign from free agent pool (off-season only)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Runs once per off-season after player development (which handles expirations).
        // Each AI team scans the pool and signs players to fill roster gaps if they
        // can afford them under their tier's cap. Keeps the pool lean and competitive.
        function aiSigningPhase() {
            const userTeam = getUserTeam();
            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
            const aiTeams = allTeams.filter(t => t.id !== userTeam.id);
            
            const totalSigned = FreeAgencyEngine.aiSigningPhase(
                { aiTeams, freeAgentPool: gameState.freeAgents },
                { TeamFactory, getEffectiveCap, calculateTeamSalary }
            );
            
            console.log(`‚úÖ AI signing phase complete: ${totalSigned} total signings across all teams`);
            console.log(`üìã Free agent pool remaining: ${gameState.freeAgents.length} players`);
        }

        // Player name generators ‚Üí Delegated to TeamFactory
        const FIRST_NAMES = TeamFactory.FIRST_NAMES;
        const LAST_NAMES = TeamFactory.LAST_NAMES;
        const POSITIONS = TeamFactory.POSITIONS;

        // ‚îÄ‚îÄ‚îÄ Convenience aliases for engine functions used throughout ‚îÄ‚îÄ‚îÄ
        const formatCurrency = SalaryCapEngine.formatCurrency;
        const calculateTeamSalary = SalaryCapEngine.calculateTeamSalary;
        const getEffectiveCap = SalaryCapEngine.getEffectiveCap;
        const getSalaryCap = SalaryCapEngine.getSalaryCap;
        const getRemainingCap = SalaryCapEngine.getRemainingCap;
        const isUnderCap = SalaryCapEngine.isUnderCap;
        const getRatingColor = UIHelpers.getRatingColor;
        const getRankSuffix = UIHelpers.getRankSuffix;
        const generatePositionBreakdownHTML = UIHelpers.generatePositionBreakdownHTML;
        function getTierBadge(player) {
            const natTier = getPlayerNaturalTier(player);
            const colors = { 1: '#ff6b6b', 2: '#4ecdc4', 3: '#95afc0' };
            const labels = { 1: 'T1', 2: 'T2', 3: 'T3' };
            return `<span style="background:${colors[natTier]};color:#fff;padding:1px 6px;border-radius:3px;font-size:0.75em;font-weight:bold;margin-left:5px;" title="Valued at Tier ${natTier} rates">${labels[natTier]}</span>`;
        }
        const sortTeamsByStandings = LeagueManager.sortTeamsByStandings;
        const calculateTeamStrength = LeagueManager.calculateTeamStrength;
        const calculateTeamChemistry = ChemistryEngine.calculate;
        const getChemistryColor = ChemistryEngine.getColor;
        const getChemistryDescription = ChemistryEngine.getDescription;
        const getFatigueColor = FatigueEngine.getColor;
        const getFatigueDescription = FatigueEngine.getDescription;
        const generateSalary = TeamFactory.generateSalary;
        const generateRoster = (tier, teamId) => TeamFactory.generateRoster(tier, teamId, { PlayerAttributes, SalaryCapEngine });
        const generateFreeAgentPool = () => TeamFactory.generateFreeAgentPool(999000, { PlayerAttributes });
        function ensureRosterExists(team) {
            if (!team.roster || team.roster.length === 0) {
                team.roster = generateRoster(team.tier, team.id);
                console.log(`Generated roster for ${team.name} (${team.roster.length} players)`);
            } else {
                let addedSalaries = false;
                let addedContracts = false;
                team.roster.forEach(player => {
                    if (!player.salary) {
                        player.salary = generateSalary(player.rating, team.tier);
                        addedSalaries = true;
                    }
                    if (!player.contractYears) {
                        player.contractYears = determineContractLength(player.age, player.rating);
                        player.originalContractLength = player.contractYears;
                        addedContracts = true;
                    }
                });
                if (addedSalaries) console.log(`Added salaries to ${team.name} roster`);
                if (addedContracts) console.log(`Added contracts to ${team.name} roster`);
            }
            FinanceEngine.ensureFinances(team);
            return team.roster;
        }
        const determineContractLength = TeamFactory.determineContractLength;
        const getPlayerNaturalTier = TeamFactory.getPlayerNaturalTier;
        const getMarketValue = TeamFactory.getMarketValue;
        const getNaturalMarketValue = TeamFactory.getNaturalMarketValue;
        const generateSchedule = TeamFactory.generateSchedule;
        const assignDivision = DivisionManager.assignDivision;
        const calculateTeamFit = ScoutingEngine.calculateTeamFit;
        const gradeColor = ScoutingEngine.gradeColor;
        const applyInjury = InjuryEngine.applyInjury;
        const applyDropPenalty = ChemistryEngine.applyDropPenalty;
        const initializePlayerChemistry = ChemistryEngine.initializePlayer;
        function simulateGame(homeTeam, awayTeam) {
            ensureRosterExists(homeTeam);
            ensureRosterExists(awayTeam);
            const result = simulationController.simulateFullGame(homeTeam, awayTeam, false);
            return result;
        }
        function simulatePlayoffGame(homeTeam, awayTeam, isHomeGame) {
            ensureRosterExists(homeTeam);
            ensureRosterExists(awayTeam);
            const result = GameEngine.calculateGameOutcome(homeTeam, awayTeam, true);
            simulationController.accumulatePlayerStats(homeTeam, result.homePlayerStats);
            simulationController.accumulatePlayerStats(awayTeam, result.awayPlayerStats);
            return {
                homeTeam, awayTeam,
                homeScore: result.homeScore, awayScore: result.awayScore,
                winner: result.winner, isHomeGame
            };
        }
        const simulatePlayoffSeries = (higherSeed, lowerSeed, bestOf) => simulationController.simulatePlayoffSeries(higherSeed, lowerSeed, bestOf);

        // Generate a random player ‚Üí Delegated to TeamFactory
        // ===== CHEMISTRY SYSTEM ‚Üí Delegated to ChemistryEngine =====
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INJURY SYSTEM ‚Üí Delegated to InjuryEngine
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // INJURY_TYPES constant now lives in InjuryEngine.INJURY_TYPES
        // Kept as local reference for any direct access patterns
        const INJURY_TYPES = InjuryEngine.INJURY_TYPES;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FATIGUE SYSTEM ‚Üí Delegated to FatigueEngine
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Get chemistry description
        // ===== DRAFT SYSTEM =====
        
        // Generate draft prospects
        // ===== DRAFT LOTTERY =====
        
        // Simulate draft lottery (NBA-style flattened odds)
        // Show lottery results modal
        // Generate draft order based on standings (TIER 1 ONLY) - WITH LOTTERY
        // ===== DRAFT PICK TRADING =====
        
        // Initialize draft pick ownership (each team owns their own picks by default)
        // Get who owns a team's pick for a given year/round
        // Trade a draft pick
        // Get all picks owned by a team for a given year
        // Check if trading a pick violates Ted Stepien Rule
        // Calculate draft pick value (depreciates over time)
        // Execute the draft (AI drafts for all teams, user drafts for their team)
        // Make functions globally accessible
        // Get salary for drafted player based on pick number and tier
        // Scales proportionally to each tier's salary cap so pick values
        // are meaningful relative to the team's financial constraints.
        // Base scale is designed for Tier 2 ($12M cap), then multiplied.
        // Run draft and show results
        // Determine contract length based on player age and rating
        // Generate salary based on player rating
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Determine the highest tier a player is qualified to play in
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Based on the same rating thresholds used for tier matching:
        //   T1: 70+ can play in Tier 1
        //   T2: 60+ can play in Tier 2 (but T1-caliber players aim for T1)
        //   T3: 50+ can play in Tier 3
        // Returns the HIGHEST tier a player would realistically target,
        // which drives their market value expectations.
        // Get a colored tier badge for display (UI - stays inline)
        // Format market value display (UI - stays inline)
        function formatMarketDisplay(player, userTier) {
            const natTier = TeamFactory.getPlayerNaturalTier(player);
            const tierValue = TeamFactory.getMarketValue(player, userTier);
            const badge = getTierBadge(player);
            
            if (natTier < userTier) {
                const natValue = TeamFactory.getNaturalMarketValue(player);
                return `${SalaryCapEngine.formatCurrency(tierValue)} ${badge}<br><span style="font-size:0.8em;color:#ff6b6b;opacity:0.9;">T${natTier} value: ${SalaryCapEngine.formatCurrency(natValue)}</span>`;
            }
            return `${SalaryCapEngine.formatCurrency(tierValue)} ${badge}`;
        }
        
        // Generate a roster for a team (cap-compliant with realistic salary distribution)
        // Ensure a team has a roster (backward compatibility)
        // Generate free agent pool
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DIVISION SYSTEM ‚Üí Delegated to DivisionManager
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const CITY_TO_DIVISIONS = window._CTD;
        const T1_NEIGHBORS = DivisionManager.T1_NEIGHBORS;
        const T2_NEIGHBORS = DivisionManager.T2_NEIGHBORS;
        const T3_NEIGHBORS = DivisionManager.T3_NEIGHBORS;
        
        // Select starting tier
        function selectTier(tier) {
            // Safety check - gameState might not be initialized yet during initial load
            if (!gameState || !gameState.tier1Teams || !gameState.tier2Teams || !gameState.tier3Teams) {
                console.warn('selectTier called before gameState initialized');
                return;
            }
            
            document.getElementById('tier1Teams').style.display = 'none';
            document.getElementById('tier2Teams').style.display = 'none';
            document.getElementById('tier3Teams').style.display = 'none';
            
            if (tier === 1) {
                document.getElementById('tier1Teams').style.display = 'grid';
                populateTeamSelection(gameState.tier1Teams, 1);
            } else if (tier === 2) {
                document.getElementById('tier2Teams').style.display = 'grid';
                populateTeamSelection(gameState.tier2Teams, 2);
            } else {
                document.getElementById('tier3Teams').style.display = 'grid';
                populateTeamSelection(gameState.tier3Teams, 3);
            }
        }
        // Make it globally accessible
        // Populate team selection
        function populateTeamSelection(teams, tier) {
            const containerId = tier === 1 ? 'tier1Teams' : tier === 2 ? 'tier2Teams' : 'tier3Teams';
            const container = document.getElementById(containerId);
            
            const divisions = {};
            teams.forEach(team => {
                if (!divisions[team.division]) divisions[team.division] = [];
                divisions[team.division].push(team);
            });

            container.innerHTML = Object.entries(divisions).map(([division, divTeams]) => `
                <div>
                    <h3 style="margin-bottom: 10px; text-align: center; opacity: 0.8;">${division}</h3>
                    ${divTeams.map(team => {
                        FinanceEngine.ensureFinances(team);
                        const revenue = FinanceEngine.getTotalRevenue(team);
                        const spendingLimit = FinanceEngine.getSpendingLimit(team);
                        const marketLabel = team.finances.marketSize >= 1.2 ? 'üèôÔ∏è' : team.finances.marketSize >= 1.0 ? 'üèòÔ∏è' : team.finances.marketSize >= 0.8 ? 'üè°' : 'üèöÔ∏è';
                        const fanbase = team.finances.fanbase;
                        return UIRenderer.teamSelectionCard({ team, tier, marketLabel, spendingLimit, fanbase, formatCurrency });
                    }).join('')}
                </div>
            `).join('');
        }

        // Select team and start game
        function selectTeam(teamId, tier) {
            gameState.userTeamId = teamId;
            gameState.currentTier = tier;
            gameState.seasonStartYear = 2025;
            gameState.currentSeason = 2025;
            
            // Get season calendar dates
            const seasonDates = CalendarEngine.getSeasonDates(gameState.seasonStartYear);
            
            // Set current date to the earliest tier start (T1 start)
            gameState.currentDate = CalendarEngine.toDateString(seasonDates.t1Start);
            
            // Generate calendar-aware schedules for ALL tiers
            const t1Start = CalendarEngine.toDateString(seasonDates.t1Start);
            const t2Start = CalendarEngine.toDateString(seasonDates.t2Start);
            const t3Start = CalendarEngine.toDateString(seasonDates.t3Start);
            const seasonEnd = CalendarEngine.toDateString(seasonDates.seasonEnd);
            
            console.log('üìÖ Generating calendar schedules...');
            console.log(`  T1: ${t1Start} to ${seasonEnd} (82 games)`);
            console.log(`  T2: ${t2Start} to ${seasonEnd} (60 games)`);
            console.log(`  T3: ${t3Start} to ${seasonEnd} (40 games)`);
            
            gameState.tier1Schedule = CalendarEngine.generateCalendarSchedule(
                gameState.tier1Teams, 82, t1Start, seasonEnd, seasonDates
            );
            gameState.tier2Schedule = CalendarEngine.generateCalendarSchedule(
                gameState.tier2Teams, 60, t2Start, seasonEnd, seasonDates
            );
            gameState.tier3Schedule = CalendarEngine.generateCalendarSchedule(
                gameState.tier3Teams, 40, t3Start, seasonEnd, seasonDates
            );
            
            // Set the user's schedule reference
            if (tier === 1) gameState.schedule = gameState.tier1Schedule;
            else if (tier === 2) gameState.schedule = gameState.tier2Schedule;
            else gameState.schedule = gameState.tier3Schedule;
            
            console.log('üìÖ Calendar schedules generated!');
            console.log(`  T1: ${gameState.tier1Schedule.length} games`);
            console.log(`  T2: ${gameState.tier2Schedule.length} games`);
            console.log(`  T3: ${gameState.tier3Schedule.length} games`);
            
            // Ensure all teams have rosters (backward compatibility)
            [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams].forEach(team => {
                ensureRosterExists(team);
            });
            
            // Generate free agent pool if not exists
            if (!gameState.freeAgents || gameState.freeAgents.length === 0) {
                gameState.freeAgents = generateFreeAgentPool();
            }
            
            saveGameState();
            document.getElementById('teamSelectionModal').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            
            console.log('‚úÖ Game started with team:', teamId, 'in tier:', tier);
            console.log('üìÖ Starting date:', gameState.currentDate);
            console.log('Initial tier counts: T1=' + gameState.tier1Teams.length + ', T2=' + gameState.tier2Teams.length + ', T3=' + gameState.tier3Teams.length);
            
            updateUI();
        }
        // Make it globally accessible
        // Generate schedule
        // Simulate game
        // Calculate team strength from roster
        // Get home court advantage (universal for all game simulations)
        // Future: can be customized per team (altitude, crowd noise, etc.)
        // ============================================
        // PHASE 2 MIGRATION: Updated Functions
        // ============================================
        // This replaces the old GameEngine.simulateGame() and GameEngine.simulatePlayoffGame() functions
        // to use the new SimulationController architecture
        
        /**
         * MIGRATED: GameEngine.simulateGame() now uses simulationController
         * This is the main function called throughout the codebase
         * Now properly separated: calculation vs state updates
         */
        /**
         * MIGRATED: GameEngine.simulatePlayoffGame() now uses GameEngine
         * Pure calculation - doesn't modify team records
         * Used by playoff series simulation
         */
        // ============================================
        // ENHANCED SIMULATION CONTROLLER
        // ============================================
        // Add playoff-specific simulation method
        
        /**
         * Simulate a playoff game (doesn't update team records, just returns result)
         * @param {Object} homeTeam - Home team
         * @param {Object} awayTeam - Away team
         * @returns {Object} Game result
         */
        SimulationController.prototype.simulatePlayoffGame = function(homeTeam, awayTeam) {
            // Use GameEngine for pure calculation (now powered by StatEngine)
            const result = GameEngine.calculateGameOutcome(homeTeam, awayTeam, true);
            
            // Accumulate player stats for playoff games too
            this.accumulatePlayerStats(homeTeam, result.homePlayerStats);
            this.accumulatePlayerStats(awayTeam, result.awayPlayerStats);
            
            // Notify observers but don't update team records
            this.notifyObservers('playoffGameComplete', result);
            
            return result;
        };
        
        /**
         * Simulate an entire playoff series
         * @param {Object} higherSeed - Higher seeded team
         * @param {Object} lowerSeed - Lower seeded team  
         * @param {number} bestOf - Series length (5 or 7)
         * @returns {Object} Series result with all game details
         */
        SimulationController.prototype.simulatePlayoffSeries = function(higherSeed, lowerSeed, bestOf) {
            const gamesToWin = Math.ceil(bestOf / 2);
            let higherSeedWins = 0;
            let lowerSeedWins = 0;
            const games = [];
            
            // Home court advantage pattern
            const homePattern = bestOf === 7 
                ? [true, true, false, false, true, false, true] // 2-2-1-1-1
                : [true, true, false, false, true]; // 2-2-1
            
            let gameNum = 0;
            while (higherSeedWins < gamesToWin && lowerSeedWins < gamesToWin) {
                const isHigherSeedHome = homePattern[gameNum];
                const homeTeam = isHigherSeedHome ? higherSeed : lowerSeed;
                const awayTeam = isHigherSeedHome ? lowerSeed : higherSeed;
                
                // Use the playoff game simulation
                const gameResult = this.simulatePlayoffGame(homeTeam, awayTeam);
                
                if (gameResult.winner.id === higherSeed.id) {
                    higherSeedWins++;
                } else {
                    lowerSeedWins++;
                }
                
                games.push({
                    gameNumber: gameNum + 1,
                    homeTeam: homeTeam,
                    awayTeam: awayTeam,
                    homeScore: gameResult.homeScore,
                    awayScore: gameResult.awayScore,
                    winner: gameResult.winner
                });
                
                gameNum++;
            }
            
            const result = {
                higherSeed: higherSeed,
                lowerSeed: lowerSeed,
                winner: higherSeedWins >= gamesToWin ? higherSeed : lowerSeed,
                loser: higherSeedWins >= gamesToWin ? lowerSeed : higherSeed,
                higherSeedWins: higherSeedWins,
                lowerSeedWins: lowerSeedWins,
                games: games,
                seriesScore: `${higherSeedWins}-${lowerSeedWins}`
            };
            
            // Notify observers
            this.notifyObservers('playoffSeriesComplete', result);
            
            return result;
        };
        
        // ============================================
        // LEGACY WRAPPER FOR PLAYOFF SERIES
        // ============================================
        // Keep the old function name working
        
        /**
         * Legacy wrapper for simulatePlayoffSeries
         * BACKWARD COMPATIBLE
         */
        // ============================================
        // PHASE 2 MIGRATION COMPLETE
        // ============================================
        /*
         * WHAT CHANGED:
         * ‚úÖ GameEngine.simulateGame() now uses simulationController.simulateFullGame()
         * ‚úÖ GameEngine.simulatePlayoffGame() now uses GameEngine.calculateGameOutcome()
         * ‚úÖ Added simulationController.GameEngine.simulatePlayoffGame() method
         * ‚úÖ Added simulationController.GameEngine.simulatePlayoffSeries() method
         * ‚úÖ All old function calls still work (backward compatible)
         * 
         * BENEFITS:
         * ‚úÖ No code duplication
         * ‚úÖ Single source of truth for game simulation
         * ‚úÖ Observer pattern works throughout
         * ‚úÖ Easier to add features (Coach mode, Board mode)
         * ‚úÖ Cleaner, more maintainable code
         * 
         * WHAT STILL WORKS:
         * ‚úÖ GameEngine.simulateGame(team1, team2) - works as before
         * ‚úÖ GameEngine.simulatePlayoffSeries(seed1, seed2, 7) - works as before
         * ‚úÖ All existing saves load correctly
         * ‚úÖ All UI functions work unchanged
         */
        

        // Get current teams
        function getCurrentTeams() {
            if (gameState.currentTier === 1) return gameState.tier1Teams;
            if (gameState.currentTier === 2) return gameState.tier2Teams;
            return gameState.tier3Teams;
        }
        // Helper function to get user's team
        function getUserTeam() {
            // First try current tier
            const currentTierTeams = getCurrentTeams();
            let userTeam = currentTierTeams.find(t => t.id === gameState.userTeamId);
            
            // If not found in current tier, search all tiers
            // (This can happen during promotion/relegation)
            if (!userTeam) {
                const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
                userTeam = allTeams.find(t => t.id === gameState.userTeamId);
                
                if (userTeam) {
                    console.log('‚ö†Ô∏è User team found in tier', userTeam.tier, 'but gameState.currentTier is', gameState.currentTier);
                }
            }
            
            return userTeam;
        }

        // ============================================
        // LEGACY SIMULATION FUNCTIONS REMOVED
        // ============================================
        // The following functions have been removed because they're replaced by GMMode class:
        // - simNextGame() ‚Üí GMMode.simulateNextGame()
        // - simDay() ‚Üí GMMode.simulateDay()
        // - finishSeason() ‚Üí GMMode.finishSeason()
        // - finishSeasonBatch() ‚Üí GMMode.finishSeasonBatch()
        // - simulateOtherTiersProportionally() ‚Üí GMMode.simulateOtherTiersProportionally()
        // - continueAfterInjuries() ‚Üí handled in injury modal flow
        // 
        // All game simulation now goes through the GMMode class which has proper
        // injury checking, chemistry updates, and trade proposal handling integrated.
        // ============================================

        // Show season end modal
        // Start playoff simulation
        // Simulate playoff bracket
        // Simulate single playoff game
        // Simulate single playoff game (simple version for promotion/relegation playoffs)
        // Show playoff results
        // ===== TIER 1 CHAMPIONSHIP PLAYOFFS =====
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FINANCIAL TRANSITION BRIEFING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Shows after promotion/relegation, before draft/free agency.
        // Gives the player a clear picture of their new financial reality
        // so they can plan roster decisions accordingly.
        
        // Advance to next season
        // Start next season
        // OLD FUNCTION - DEPRECATED (kept for backward compatibility only)
        // Flow: advanceToNextSeason ‚Üí PlayoffEngine.simulateFullPostseason ‚Üí continueAfterPostseason ‚Üí executePromotionRelegationFromResults ‚Üí proceedToDraftOrDevelopment ‚Üí collegeGradFA ‚Üí playerDevelopment ‚Üí rosterCompliance ‚Üí offseasonManagement ‚Üí continueToSeasonSetup
        function startNextSeason() {
            console.error('‚ö†Ô∏è startNextSeason called - this function is deprecated!');
            console.error('The new season flow is: Season End ‚Üí Playoffs ‚Üí Promotion/Relegation ‚Üí Draft (T1 only) ‚Üí Development ‚Üí Roster Check ‚Üí Season Setup');
            console.error('If you see this message, there is a bug in the flow. Please report it.');
        }

        // Simulate all tiers (except user's) to completion for end-of-season
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STEP 3b: COLLEGE GRADUATE FREE AGENCY
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // After the T1 draft, generate a class of college graduates (21-22 yr olds)
        // who enter the market for T2/T3 teams. These represent 3-year college
        // players who weren't drafted by T1 but are young, developing talent.
        //
        // Flow: Generate graduates ‚Üí T2/T3 user picks ‚Üí AI teams sign ‚Üí remainder
        // goes to general FA pool ‚Üí continue to player development.
        
        const COLLEGE_NAMES = TeamFactory.COLLEGE_NAMES;
        
        let collegeGradIdCounter = 800000;
        
        // Step 4: Player Development
        let playerDevelopmentInProgress = false;
        
        // ============================================
        // CALENDAR VIEW
        // ============================================
        // FINANCE DASHBOARD
        // ============================================
        
        // ============================================
        // CALENDAR VIEW
        // ============================================
        
        function openCalendarView() {
            const modal = document.getElementById('calendarModal');
            const content = document.getElementById('calendarContent');
            
            if (!gameState || !gameState.currentDate) {
                content.innerHTML = '<h2 style="text-align: center;">No season in progress</h2>';
                modal.classList.remove('hidden');
                return;
            }
            
            const currentDate = gameState.currentDate;
            const startYear = gameState.seasonStartYear || 2025;
            const seasonDates = CalendarEngine.getSeasonDates(startYear);
            
            // Build months to display
            const months = [];
            for (let m = 9; m <= 11; m++) months.push({ year: startYear, month: m });
            for (let m = 0; m <= 3; m++) months.push({ year: startYear + 1, month: m });
            
            // Build user game lookup
            const userTeamId = gameState.userTeamId;
            const userTier = gameState.currentTier;
            const userSchedule = userTier === 1 ? gameState.tier1Schedule :
                                 userTier === 2 ? gameState.tier2Schedule :
                                 gameState.tier3Schedule;
            
            const userGamesByDate = {};
            if (userSchedule) {
                const allTeams = [...(gameState.tier1Teams || []), ...(gameState.tier2Teams || []), ...(gameState.tier3Teams || [])];
                userSchedule.forEach(game => {
                    if (game.date && (game.homeTeamId === userTeamId || game.awayTeamId === userTeamId)) {
                        const isHome = game.homeTeamId === userTeamId;
                        const opponentId = isHome ? game.awayTeamId : game.homeTeamId;
                        const opponent = allTeams.find(t => t.id === opponentId);
                        userGamesByDate[game.date] = { isHome, opponent, played: game.played, game };
                    }
                });
            }
            
            // Build total game count by date
            const allGamesByDate = {};
            [gameState.tier1Schedule, gameState.tier2Schedule, gameState.tier3Schedule].forEach((sched, idx) => {
                if (!sched) return;
                sched.forEach(game => {
                    if (game.date) {
                        if (!allGamesByDate[game.date]) allGamesByDate[game.date] = { total: 0, t1: 0, t2: 0, t3: 0 };
                        allGamesByDate[game.date].total++;
                        if (idx === 0) allGamesByDate[game.date].t1++;
                        else if (idx === 1) allGamesByDate[game.date].t2++;
                        else allGamesByDate[game.date].t3++;
                    }
                });
            });
            
            // Convert season dates to strings for comparison
            const calSeasonDates = {
                allStarStart: CalendarEngine.toDateString(seasonDates.allStarStart),
                allStarEnd: CalendarEngine.toDateString(seasonDates.allStarEnd),
                tradeDeadline: CalendarEngine.toDateString(seasonDates.tradeDeadline),
                tier1End: CalendarEngine.toDateString(seasonDates.tier1End)
            };
            
            content.innerHTML = UIRenderer.calendarGrid({
                months, currentDate, userGamesByDate, allGamesByDate,
                seasonDates: calSeasonDates, startYear
            });
            modal.classList.remove('hidden');
        }
        
        function showCalendarDayDetail(dateStr) {
            if (!gameState) return;
            
            const detail = document.getElementById('calendarDayDetail');
            if (!detail) return;
            
            const games = CalendarEngine.getGamesForDate(dateStr, gameState);
            const event = CalendarEngine.getCalendarEvent(dateStr, gameState.seasonDates);
            const allTeams = [...(gameState.tier1Teams || []), ...(gameState.tier2Teams || []), ...(gameState.tier3Teams || [])];
            const userTeamId = gameState.userTeamId;
            
            const formattedDate = CalendarEngine.formatDateDisplay(dateStr);
            
            // Collect all games with team names and scores
            const allGames = [];
            const tierSchedules = [
                { schedule: games.tier1, teams: gameState.tier1Teams, tier: 1 },
                { schedule: games.tier2, teams: gameState.tier2Teams, tier: 2 },
                { schedule: games.tier3, teams: gameState.tier3Teams, tier: 3 }
            ];
            
            for (const { schedule, teams, tier } of tierSchedules) {
                if (!schedule) continue;
                for (const game of schedule) {
                    const home = allTeams.find(t => t.id === game.homeTeamId);
                    const away = allTeams.find(t => t.id === game.awayTeamId);
                    if (!home || !away) continue;
                    allGames.push({
                        ...game,
                        homeName: home.city ? `${home.city} ${home.name}` : home.name,
                        awayName: away.city ? `${away.city} ${away.name}` : away.name,
                        tier
                    });
                }
            }
            
            const userGame = allGames.find(g => g.homeTeamId === userTeamId || g.awayTeamId === userTeamId);
            const otherGames = allGames.filter(g => g.homeTeamId !== userTeamId && g.awayTeamId !== userTeamId);
            
            let userGameHTML = '';
            if (userGame) {
                userGameHTML = UIRenderer.calendarDayScores({ games: [userGame], date: dateStr, userTeamId, showHeader: false });
            }
            let otherGamesHTML = '';
            if (otherGames.length > 0) {
                otherGamesHTML = UIRenderer.calendarDayScores({ games: otherGames, date: dateStr, userTeamId, showHeader: false });
            }
            
            detail.innerHTML = UIRenderer.calendarDayDetail({
                formattedDate, event, allGames, userGame, otherGames,
                userGameHTML, otherGamesHTML
            });
            detail.style.display = 'block';
        }
        
        function showBoxScore(dateStr, homeTeamId, awayTeamId) {
            const games = CalendarEngine.getGamesForDate(dateStr, gameState);
            const allSchedule = [...(games.tier1 || []), ...(games.tier2 || []), ...(games.tier3 || [])];
            const game = allSchedule.find(g => g.homeTeamId === homeTeamId && g.awayTeamId === awayTeamId);
            
            if (!game || !game.played) return;
            
            const allTeams = [...(gameState.tier1Teams || []), ...(gameState.tier2Teams || []), ...(gameState.tier3Teams || [])];
            const homeTeam = allTeams.find(t => t.id === homeTeamId);
            const awayTeam = allTeams.find(t => t.id === awayTeamId);
            
            if (game.boxScore) {
                // Full box score available
                document.getElementById('boxScoreContent').innerHTML = UIRenderer.boxScore({
                    home: game.boxScore.home,
                    away: game.boxScore.away,
                    date: CalendarEngine.formatDateDisplay(dateStr),
                    hasDetailedStats: true,
                    quarterScores: game.boxScore.quarterScores || null
                });
            } else {
                // Score only (non-user game)
                document.getElementById('boxScoreContent').innerHTML = UIRenderer.boxScore({
                    home: { city: homeTeam ? (homeTeam.city || '') : '', name: homeTeam ? homeTeam.name : '', score: game.homeScore, players: [] },
                    away: { city: awayTeam ? (awayTeam.city || '') : '', name: awayTeam ? awayTeam.name : '', score: game.awayScore, players: [] },
                    date: CalendarEngine.formatDateDisplay(dateStr),
                    hasDetailedStats: false
                });
            }
            
            document.getElementById('boxScoreModal').classList.remove('hidden');
        }
        // ============================================
        // WATCH GAME MODE
        // ============================================
        
        // _watch* state moved to GameSimController
        
        // _startWatchTimer moved to GameSimController
        
        // _renderWatchEvents moved to GameSimController
        
        // _updateWatchScoreboard moved to GameSimController
        
        // ============================================
        // ALL-STAR GAME
        // ============================================
        
        function buildConferenceMap(teams, tier) {
            const map = {};
            if (tier === 1) {
                const eastDivs = ['Atlantic', 'Central', 'Southeast'];
                teams.forEach(t => { map[t.id] = eastDivs.includes(t.division) ? 'East' : 'West'; });
            } else if (tier === 2) {
                const eastDivs = ['Great Lakes', 'Mid-Atlantic', 'Southeast', 'New England', 'Florida', 'Gulf Coast'];
                teams.forEach(t => { map[t.id] = eastDivs.includes(t.division) ? 'East' : 'West'; });
            } else {
                // T3: split metro leagues roughly East/West by index
                const divs = [...new Set(teams.map(t => t.division))].sort();
                const halfIdx = Math.ceil(divs.length / 2);
                const eastDivs = new Set(divs.slice(0, halfIdx));
                teams.forEach(t => { map[t.id] = eastDivs.has(t.division) ? 'East' : 'West'; });
            }
            return map;
        }
        
        function runAllStarWeekend() {
            console.log('‚≠ê Running All-Star Weekend...');
            eventBus.emit(GameEvents.SEASON_ALL_STAR, { season: gameState.season });
            
            const tierConfigs = [
                { teams: gameState.tier1Teams, tier: 1, label: 'Tier 1 ‚Äî NAPL', minPct: 0.4, color: '#ffd700' },
                { teams: gameState.tier2Teams, tier: 2, label: 'Tier 2 ‚Äî NARBL', minPct: 0.35, color: '#c0c0c0' },
                { teams: gameState.tier3Teams, tier: 3, label: 'Tier 3 ‚Äî MBL', minPct: 0.3, color: '#cd7f32' }
            ];
            
            const allStarResults = [];
            
            for (const config of tierConfigs) {
                const gamesPerTeam = config.tier === 1 ? 82 : config.tier === 2 ? 60 : 40;
                const minGames = Math.floor(gamesPerTeam * config.minPct);
                const confMap = buildConferenceMap(config.teams, config.tier);
                
                const selections = StatEngine.selectAllStars(config.teams, minGames, confMap);
                const gameResult = StatEngine.simulateAllStarGame(selections.east, selections.west, config.label);
                
                allStarResults.push({
                    ...config,
                    selections,
                    gameResult
                });
                
                console.log(`  ‚≠ê ${config.label}: ${gameResult.winner} wins ${gameResult.eastScore}-${gameResult.westScore}`);
            }
            
            // Store results on gameState so we don't re-trigger
            gameState._allStarCompleted = true;
            gameState._allStarResults = allStarResults;
            
            showAllStarModal(allStarResults);
        }
        
        function showAllStarModal(results) {
            document.getElementById('allStarContent').innerHTML = UIRenderer.allStarModal({
                results, userTeamId: gameState.userTeamId
            });
            document.getElementById('allStarModal').classList.remove('hidden');
        }
        
        function closeAllStarModal() {
            document.getElementById('allStarModal').classList.add('hidden');
        }
        
        // Close season end modal
        // Update UI
        function updateUI() {
            const teams = getCurrentTeams();
            const userTeam = teams.find(t => t.id === gameState.userTeamId);
            const numGames = gameState.currentTier === 1 ? 82 : gameState.currentTier === 2 ? 60 : 40;

            // Update tier badge
            const tierBadge = document.getElementById('tierBadge');
            tierBadge.textContent = `TIER ${gameState.currentTier}`;
            tierBadge.className = `tier-badge tier-${gameState.currentTier}`;

            // Update league name
            const leagueName = gameState.currentTier === 1 ? 
                'North American Premier League' : 
                gameState.currentTier === 2 ?
                'North American Regional Basketball League' :
                'Metro Basketball League';
            document.getElementById('leagueName').textContent = leagueName;

            // Update info cards
            document.getElementById('currentSeason').textContent = `${gameState.currentSeason}-${(gameState.currentSeason + 1) % 100}`;
            document.getElementById('currentGame').textContent = userTeam.wins + userTeam.losses;
            document.getElementById('totalGames').textContent = numGames;
            document.getElementById('userTeamName').textContent = userTeam.name;
            document.getElementById('userRecord').textContent = `${userTeam.wins}-${userTeam.losses}`;
            
            // Update current date display
            const dateDisplay = document.getElementById('currentDateDisplay');
            if (dateDisplay && gameState.currentDate) {
                dateDisplay.textContent = CalendarEngine.formatDateDisplay(gameState.currentDate);
            } else if (dateDisplay) {
                dateDisplay.textContent = '-';
            }
            
            // Show calendar events (All-Star, Trade Deadline, etc.)
            const calEventEl = document.getElementById('calendarEvent');
            if (calEventEl && gameState.currentDate) {
                const seasonDates = gameState.seasonDates;
                const calEvent = CalendarEngine.getCalendarEvent(gameState.currentDate, seasonDates);
                if (calEvent) {
                    calEventEl.textContent = calEvent;
                    calEventEl.style.display = 'block';
                } else {
                    calEventEl.style.display = 'none';
                }
            }
            
            // Display roster strength
            const rosterStrength = LeagueManager.calculateTeamStrength(userTeam);
            const strengthDisplay = document.getElementById('rosterStrength');
            if (strengthDisplay) {
                strengthDisplay.textContent = `‚≠ê ${Math.round(rosterStrength)}`;
                strengthDisplay.style.color = UIHelpers.getRatingColor(Math.round(rosterStrength));
            }
            
            // Update budget display
            const budgetDisplay = document.getElementById('budgetDisplay');
            const budgetSubDisplay = document.getElementById('budgetSubDisplay');
            if (budgetDisplay) {
                FinanceEngine.ensureFinances(userTeam);
                const capSpace = SalaryCapEngine.getRemainingCap(userTeam);
                const spLimit = SalaryCapEngine.getEffectiveCap(userTeam);
                budgetDisplay.textContent = SalaryCapEngine.formatCurrency(capSpace);
                budgetDisplay.style.color = capSpace > 0 ? '#34a853' : '#ea4335';
                budgetSubDisplay.textContent = `of ${SalaryCapEngine.formatCurrency(spLimit)} ${userTeam.tier === 1 ? 'cap' : 'limit'}`;
            }
            
            // Update coach display
            const coachNameEl = document.getElementById('coachNameDisplay');
            const coachOvrEl = document.getElementById('coachOverallDisplay');
            if (coachNameEl) {
                if (userTeam.coach) {
                    coachNameEl.textContent = userTeam.coach.name;
                    coachOvrEl.textContent = `${userTeam.coach.overall} OVR ¬∑ ${userTeam.coach.archetype}`;
                    coachOvrEl.style.color = CoachEngine.getOverallColor(userTeam.coach.overall);
                } else {
                    coachNameEl.textContent = '‚ö†Ô∏è No Coach';
                    coachNameEl.style.color = '#ea4335';
                    coachOvrEl.textContent = 'Click to hire';
                    coachOvrEl.style.color = '#ffa07a';
                }
            }

            // Update legend for tier
            if (gameState.currentTier === 2) {
                document.getElementById('promotionLegend').style.display = 'flex';
                document.getElementById('playoffLegendText').textContent = 'Promotion Playoff';
                document.getElementById('autoZoneLegendText').textContent = 'Safe';
            } else {
                document.getElementById('promotionLegend').style.display = 'none';
                document.getElementById('playoffLegendText').textContent = 'Relegation Playoff';
                document.getElementById('autoZoneLegendText').textContent = 'Auto-Relegation';
            }
            
            // Update sim button states
            const seasonComplete = gameState.isSeasonComplete();
            const inOffseason = gameState.offseasonPhase && gameState.offseasonPhase !== 'none';
            const simNextBtn = document.getElementById('simNextBtn');
            const simDayBtn = document.getElementById('simDayBtn');
            const simWeekBtn = document.getElementById('simWeekBtn');
            const finishBtn = document.getElementById('finishBtn');
            if (simNextBtn) simNextBtn.disabled = seasonComplete;
            if (simDayBtn) simDayBtn.disabled = seasonComplete;
            if (simWeekBtn) simWeekBtn.disabled = seasonComplete;
            // Keep finishBtn enabled during offseason so user can resume
            if (finishBtn) finishBtn.disabled = seasonComplete && !inOffseason;
            
            updateStandings();
            updateNextGames();
            updateSeasonHistory();
        }

        // View standings for a specific tier
        function viewTierStandings(tier) {
            gameState.viewingTier = tier;
            
            // Get teams from the requested tier
            let teams;
            let leagueName;
            let numGames;
            
            if (tier === 1) {
                teams = gameState.tier1Teams;
                leagueName = 'North American Premier League (Tier 1)';
                numGames = 82;
            } else if (tier === 2) {
                teams = gameState.tier2Teams;
                leagueName = 'North American Regional Basketball League (Tier 2)';
                numGames = 60;
            } else {
                teams = gameState.tier3Teams;
                leagueName = 'Metro Basketball League (Tier 3)';
                numGames = 40;
            }
            
            // Update the league info display
            document.getElementById('standingsLeagueInfo').textContent = `Viewing: ${leagueName}`;
            
            // Check if division view is selected
            if (gameState.standingsView === 'division') {
                displayDivisionStandings(teams);
            } else {
                displayTierOverallStandings(teams, tier);
            }
        }
        
        // Display overall standings for a specific tier (used by viewTierStandings)
        function displayTierOverallStandings(teams, tier) {
            // Sort teams by record
            const sortedTeams = LeagueManager.sortTeamsByStandings(teams, gameState.schedule);

            const tbody = document.getElementById('standingsBody');
            tbody.innerHTML = sortedTeams.map((team, index) => {
                const winPct = team.wins + team.losses > 0 ? 
                    (team.wins / (team.wins + team.losses)).toFixed(3) : '.000';
                
                let rowClass = '';
                const rank = index + 1;
                const totalTeams = teams.length;
                
                // Highlight user's team
                if (team.id === gameState.userTeamId) {
                    rowClass = 'user-team';
                } else if (tier === 2 || tier === 3) {
                    // Tier 2 & 3: rank 1 = auto-promote, 2-4 = playoff
                    if (rank === 1) {
                        rowClass = 'promotion-zone';
                    } else if (rank >= 2 && rank <= 4) {
                        rowClass = 'playoff-zone';
                    }
                } else if (tier === 1) {
                    // Tier 1: rank 30 = auto-relegate, 28-29 = playoff
                    if (rank >= totalTeams - 2 && rank <= totalTeams - 1) {
                        rowClass = 'playoff-zone';
                    } else if (rank === totalTeams) {
                        rowClass = 'auto-relegate';
                    }
                }

                return `
                    <tr class="${rowClass}">
                        <td>${rank}</td>
                        <td><strong>${team.name}</strong></td>
                        <td>${team.division}</td>
                        <td>${team.wins}</td>
                        <td>${team.losses}</td>
                        <td>${winPct}</td>
                        <td>${team.pointDiff > 0 ? '+' : ''}${team.pointDiff}</td>
                    </tr>
                `;
            }).join('');
        }
        // Make it globally accessible
        // Update standings table
        // Toggle between overall and division standings
        function toggleStandingsView(view) {
            gameState.standingsView = view;
            
            // Update button styles
            const overallBtn = document.getElementById('viewOverallBtn');
            const divisionBtn = document.getElementById('viewDivisionBtn');
            
            if (view === 'overall') {
                overallBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #5568d3 100%)';
                divisionBtn.style.background = '';
            } else {
                overallBtn.style.background = '';
                divisionBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #5568d3 100%)';
            }
            
            updateStandings();
        }

        function updateStandings() {
            // If viewing a specific tier, show that instead
            if (gameState.viewingTier !== null && gameState.viewingTier !== gameState.currentTier) {
                viewTierStandings(gameState.viewingTier);
                return;
            }
            
            // Reset to show current tier
            gameState.viewingTier = null;
            document.getElementById('standingsLeagueInfo').textContent = '';
            
            const teams = getCurrentTeams();
            
            // Check if division view is selected
            if (gameState.standingsView === 'division') {
                displayDivisionStandings(teams);
            } else {
                displayOverallStandings(teams);
            }
        }
        
        // Display overall standings
        function displayOverallStandings(teams) {
            const sortedTeams = LeagueManager.sortTeamsByStandings(teams, gameState.schedule);

            const tbody = document.getElementById('standingsBody');
            tbody.innerHTML = sortedTeams.map((team, index) => {
                const winPct = team.wins + team.losses > 0 ? 
                    (team.wins / (team.wins + team.losses)).toFixed(3) : '.000';
                
                let rowClass = '';
                const rank = index + 1;
                const totalTeams = teams.length;
                
                if (team.id === gameState.userTeamId) {
                    rowClass = 'user-team';
                } else if (gameState.currentTier === 2 || gameState.currentTier === 3) {
                    // Tier 2 & 3: rank 1 = auto-promote, 2-4 = playoff
                    if (rank === 1) {
                        rowClass = 'promotion-zone';
                    } else if (rank >= 2 && rank <= 4) {
                        rowClass = 'playoff-zone';
                    }
                } else {
                    // Tier 1: rank 30 = auto-relegate, 28-29 = playoff
                    if (rank >= totalTeams - 2 && rank <= totalTeams - 1) {
                        rowClass = 'playoff-zone';
                    } else if (rank === totalTeams) {
                        rowClass = 'auto-relegate';
                    }
                }

                return `
                    <tr class="${rowClass}">
                        <td>${rank}</td>
                        <td><strong>${team.name}</strong></td>
                        <td>${team.division}</td>
                        <td>${team.wins}</td>
                        <td>${team.losses}</td>
                        <td>${winPct}</td>
                        <td>${team.pointDiff > 0 ? '+' : ''}${team.pointDiff}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Display division standings
        function displayDivisionStandings(teams) {
            const divisions = {};
            teams.forEach(team => {
                if (!divisions[team.division]) divisions[team.division] = [];
                divisions[team.division].push(team);
            });
            
            Object.keys(divisions).forEach(division => {
                divisions[division].sort((a, b) => {
                    if (b.wins !== a.wins) return b.wins - a.wins;
                    return b.pointDiff - a.pointDiff;
                });
            });
            
            const sortedDivisions = Object.keys(divisions).sort();
            
            document.getElementById('standingsBody').innerHTML = UIRenderer.divisionStandingsRows({
                sortedDivisions, divisions, userTeamId: gameState.userTeamId
            });
        }

        // Update next games
        function updateNextGames() {
            const currentDate = gameState.currentDate;
            if (!currentDate) {
                const container = document.getElementById('nextGamesContainer');
                if (container) container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No schedule yet</p>';
                return;
            }
            
            // === TODAY'S GAMES PANEL ===
            const todaysContainer = document.getElementById('todaysGamesContainer');
            if (todaysContainer) {
                const todaysGames = CalendarEngine.getGamesForDate(currentDate, gameState);
                const unplayedToday = todaysGames.tier1.filter(g => !g.played).length +
                                     todaysGames.tier2.filter(g => !g.played).length +
                                     todaysGames.tier3.filter(g => !g.played).length;
                
                if (unplayedToday > 0) {
                    const userTier = gameState.currentTier;
                    let userTierTeams = [];
                    if (userTier === 1) userTierTeams = gameState.tier1Teams;
                    else if (userTier === 2) userTierTeams = gameState.tier2Teams;
                    else userTierTeams = gameState.tier3Teams;
                    
                    todaysContainer.innerHTML = UIRenderer.todaysGamesPanel({
                        todaysGames, userTier, userTeams: userTierTeams,
                        userTeamId: gameState.userTeamId, currentDate, CalendarEngine
                    });
                } else {
                    todaysContainer.innerHTML = '';
                }
            }
            
            // === UPCOMING USER SCHEDULE ===
            const container = document.getElementById('nextGamesContainer');
            if (!container) return;
            
            const userTeamId = gameState.userTeamId;
            const userTier = gameState.currentTier;
            let userSchedule;
            let userTeams;
            if (userTier === 1) { userSchedule = gameState.tier1Schedule; userTeams = gameState.tier1Teams; }
            else if (userTier === 2) { userSchedule = gameState.tier2Schedule; userTeams = gameState.tier2Teams; }
            else { userSchedule = gameState.tier3Schedule; userTeams = gameState.tier3Teams; }
            
            if (!userSchedule) {
                container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No schedule available</p>';
                return;
            }
            
            const upcomingGames = userSchedule.filter(g => 
                !g.played && 
                g.date >= currentDate &&
                (g.homeTeamId === userTeamId || g.awayTeamId === userTeamId)
            ).slice(0, 5);
            
            if (upcomingGames.length === 0) {
                container.innerHTML = '<p style="text-align: center; opacity: 0.7;">Season complete!</p>';
                return;
            }
            
            container.innerHTML = UIRenderer.upcomingGamesPanel({
                upcomingGames, userTeams, userTeamId, CalendarEngine
            });
        }

        // Update season history
        function updateSeasonHistory() {
            if (gameState.seasonHistory.length === 0) {
                document.getElementById('seasonHistory').style.display = 'none';
                return;
            }

            document.getElementById('seasonHistory').style.display = 'block';
            
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = gameState.seasonHistory.map(season => `
                <div class="history-item">
                    <span><strong>${season.season}</strong></span>
                    <span>Tier ${season.tier}</span>
                    <span>${season.wins}-${season.losses}</span>
                    <span>${season.rank}${UIHelpers.getRankSuffix(season.rank)} place</span>
                    <span>${season.pointDiff > 0 ? '+' : ''}${season.pointDiff} diff</span>
                </div>
            `).join('');
        }

        // Reset game
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SCOUTING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Watch list persists across sessions via gameState
        function getAllLeaguePlayers() {
            const all = [];
            [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams].forEach(team => {
                if (team.roster) {
                    team.roster.forEach(p => {
                        p._teamName = team.name;
                        p._teamTier = team.tier;
                        p._teamId = team.id;
                        all.push(p);
                    });
                }
            });
            return all;
        }
        
        // ‚îÄ‚îÄ‚îÄ SYSTEM FIT CALCULATION ‚îÄ‚îÄ‚îÄ
        // How well a player's attributes match the user's coach system
        // ‚îÄ‚îÄ‚îÄ UI FUNCTIONS ‚îÄ‚îÄ‚îÄ
        
        // Store current scanner filters
        window._scoutFilters = { pos: 'ALL', tier: 'ALL', minAge: '', maxAge: '', minRating: '', maxRating: '', contractStatus: 'ALL', sort: 'fit' };
        
        // ‚îÄ‚îÄ‚îÄ COLLEGE PIPELINE TAB ‚îÄ‚îÄ‚îÄ
        // ‚îÄ‚îÄ‚îÄ WATCH LIST TAB ‚îÄ‚îÄ‚îÄ
        // ‚îÄ‚îÄ‚îÄ TEAM NEEDS TAB ‚îÄ‚îÄ‚îÄ
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FRANCHISE HISTORY
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function openFranchiseHistory() {
            const history = gameState._fullSeasonHistory || gameState.fullSeasonHistory || [];
            document.getElementById('franchiseHistoryContent').innerHTML = UIRenderer.franchiseHistory({
                history,
                getRankSuffix
            });
            document.getElementById('franchiseHistoryModal').classList.remove('hidden');
        }
        
        function resetGame() {
            if (confirm('Are you sure you want to reset? All progress will be lost.')) {
                StorageEngine.clearAll().then(() => {
                    location.reload();
                }).catch(() => {
                    // Fallback: clear localStorage manually and reload
                    localStorage.removeItem('gbslMultiTierGameState');
                    localStorage.removeItem('gbslSaveData');
                    location.reload();
                });
            }
        }

        // Save game state to localStorage
        function saveGameState() {
            // Use StorageEngine (IndexedDB with localStorage fallback)
            StorageEngine.save(gameState).then(result => {
                if (result.success) {
                    console.log(`üíæ Saved (${result.sizeKB}KB via ${result.storage})`);
                    eventBus.emit(GameEvents.GAME_SAVED, { sizeKB: result.sizeKB, storage: result.storage });
                } else {
                    console.error('‚ùå Save returned failure');
                    // Emergency fallback: write directly to localStorage
                    try {
                        const data = gameState.serialize ? gameState.serialize() : JSON.stringify(gameState);
                        localStorage.setItem('gbslSaveData', data);
                        console.log('üÜò Emergency save to localStorage:', Math.round(data.length/1024), 'KB');
                    } catch(e) {
                        console.error('Emergency save also failed:', e);
                    }
                }
            }).catch(err => {
                console.error('‚ùå Save error:', err);
                // Emergency fallback
                try {
                    const data = gameState.serialize ? gameState.serialize() : JSON.stringify(gameState);
                    localStorage.setItem('gbslSaveData', data);
                    console.log('üÜò Emergency save to localStorage:', Math.round(data.length/1024), 'KB');
                } catch(e) {
                    console.error('Emergency save also failed:', e);
                }
            });
        }

        // Load game state from localStorage
        function loadGameState() {
            try {
                const saved = localStorage.getItem('gbslMultiTierGameState');
                if (saved) {
                    const loaded = JSON.parse(saved);
                    if (loaded.userTeamId) {
                        gameState = loaded;
                        
                        // Ensure tier3Teams exists (for old saves that don't have it)
                        if (!gameState.tier3Teams || gameState.tier3Teams.length === 0) {
                            console.log('Initializing Tier 3 for old save...');
                            gameState.tier3Teams = TeamFactory.initializeTierTeams(3, generateRoster);
                        }
                        
                        // Ensure viewingTier exists
                        if (gameState.viewingTier === undefined) {
                            gameState.viewingTier = null;
                        }
                        
                        // Ensure tier schedules exist (for background simulation)
                        if (!gameState.tier1Schedule || gameState.tier1Schedule.length === 0) {
                            console.log('Initializing tier schedules for old save...');
                            gameState.tier1Schedule = TeamFactory.generateSchedule(gameState.tier1Teams, 82);
                            gameState.tier2Schedule = TeamFactory.generateSchedule(gameState.tier2Teams, 60);
                            gameState.tier3Schedule = TeamFactory.generateSchedule(gameState.tier3Teams, 40);
                        }
                        
                        // === CALENDAR MIGRATION ===
                        // If loading an old save without calendar dates, migrate it
                        if (!gameState.currentDate) {
                            console.log('üìÖ Migrating old save to calendar system...');
                            const startYear = gameState.currentSeason || 2025;
                            gameState.seasonStartYear = startYear;
                            const seasonDates = CalendarEngine.getSeasonDates(startYear);
                            gameState.currentDate = CalendarEngine.toDateString(seasonDates.t1Start);
                            
                            // Check if schedules need date assignment
                            if (gameState.tier1Schedule.length > 0 && !gameState.tier1Schedule[0].date) {
                                console.log('  Regenerating schedules with calendar dates...');
                                const t1Start = CalendarEngine.toDateString(seasonDates.t1Start);
                                const t2Start = CalendarEngine.toDateString(seasonDates.t2Start);
                                const t3Start = CalendarEngine.toDateString(seasonDates.t3Start);
                                const seasonEnd = CalendarEngine.toDateString(seasonDates.seasonEnd);
                                
                                gameState.tier1Schedule = CalendarEngine.generateCalendarSchedule(
                                    gameState.tier1Teams, 82, t1Start, seasonEnd, seasonDates
                                );
                                gameState.tier2Schedule = CalendarEngine.generateCalendarSchedule(
                                    gameState.tier2Teams, 60, t2Start, seasonEnd, seasonDates
                                );
                                gameState.tier3Schedule = CalendarEngine.generateCalendarSchedule(
                                    gameState.tier3Teams, 40, t3Start, seasonEnd, seasonDates
                                );
                                
                                if (gameState.currentTier === 1) gameState.schedule = gameState.tier1Schedule;
                                else if (gameState.currentTier === 2) gameState.schedule = gameState.tier2Schedule;
                                else gameState.schedule = gameState.tier3Schedule;
                                
                                console.log('  ‚úÖ Calendar migration complete');
                            }
                        }
                        
                        // Ensure all teams have rosters (backward compatibility)
                        console.log('Checking rosters for backward compatibility...');
                        let rostersGenerated = 0;
                        let playersMigrated = 0;
                        [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams].forEach(team => {
                            if (!team.roster || team.roster.length === 0) {
                                team.roster = generateRoster(team.tier, team.id);
                                rostersGenerated++;
                            }
                            // === COACH MIGRATION: Ensure all teams have coaches ===
                            if (!team.coach) {
                                team.coach = CoachEngine.generateCoach(team.tier);
                                team.coach.teamId = team.id;
                            }
                            // === ATTRIBUTE MIGRATION: Ensure all players have attributes ===
                            if (team.roster) {
                                team.roster.forEach(player => {
                                    if (PlayerAttributes.ensureAttributes(player)) {
                                        playersMigrated++;
                                        // Update fatigue threshold based on new endurance attribute
                                        if (player.attributes && player.attributes.endurance) {
                                            player.fatigueThreshold = Math.max(60, Math.min(90, 65 + Math.round((player.attributes.endurance - 50) * 0.4)));
                                        }
                                    }
                                });
                            }
                        });
                        if (rostersGenerated > 0) {
                            console.log(`Generated ${rostersGenerated} rosters for existing teams`);
                        }
                        if (playersMigrated > 0) {
                            console.log(`üèãÔ∏è Migrated ${playersMigrated} players to attribute system`);
                        }
                        // Migrate free agents too
                        if (gameState.freeAgents) {
                            gameState.freeAgents.forEach(player => {
                                PlayerAttributes.ensureAttributes(player);
                            });
                        }
                        
                        // Ensure free agents exist
                        if (!gameState.freeAgents || gameState.freeAgents.length === 0) {
                            console.log('Generating free agent pool...');
                            gameState.freeAgents = generateFreeAgentPool();
                        }
                        
                        return true;
                    }
                }
            } catch(e) {
                console.log('Could not load saved game');
            }
            return false;
        }

        // Make functions globally accessible for onclick handlers
        // Note: simNextGame, simDay, finishSeason are now handled by GMMode class
        // ===== ROSTER MANAGEMENT FUNCTIONS =====
        
        let currentFreeAgentFilter = { position: 'ALL', tier: 'ALL', sort: 'rating' };

        // Track where roster management was opened from
        let rosterManagementReturnContext = 'seasonEnd'; // 'seasonEnd', 'compliance', 'development'
        
        function openRosterManagement() {
            console.log('üìã Opening Roster Management');
            console.log('User Team ID:', gameState.userTeamId);
            console.log('Current Tier:', gameState.currentTier);
            
            const userTeam = getUserTeam();
            console.log('User Team:', userTeam ? userTeam.name : 'NOT FOUND');
            
            if (!userTeam) {
                alert('Error: Could not find your team!');
                return;
            }
            
            ensureRosterExists(userTeam);
            console.log('User Roster Size:', userTeam.roster ? userTeam.roster.length : 0);
            console.log('Free Agents Count:', gameState.freeAgents ? gameState.freeAgents.length : 0);
            
            // Set return context based on what's currently open
            if (!document.getElementById('seasonEndModal').classList.contains('hidden')) {
                rosterManagementReturnContext = 'seasonEnd';
            } else {
                rosterManagementReturnContext = 'game';
            }
            
            document.getElementById('seasonEndModal').classList.add('hidden');
            document.getElementById('rosterModal').classList.remove('hidden');
            
            getRosterController().updateRosterDisplay();
            filterFreeAgents();
        }

        function closeRosterManagement() {
            document.getElementById('rosterModal').classList.add('hidden');
            saveGameState();
            
            // If we're in the offseason flow, resume from current phase
            if (getOffseasonController().isInOffseason()) {
                console.log('Returning from roster management to offseason flow (phase:', gameState.offseasonPhase, ')');
                if (rosterManagementReturnContext === 'compliance') {
                    // Go back to compliance check specifically
                    getOffseasonController().checkRosterComplianceAndContinue();
                } else {
                    // Resume from whatever phase we're in
                    getOffseasonController().resumeOffseason();
                }
                return;
            }
            
            // Regular season contexts
            if (rosterManagementReturnContext === 'compliance') {
                console.log('Returning from roster management to compliance check...');
                getOffseasonController().checkRosterComplianceAndContinue();
            } else if (rosterManagementReturnContext === 'development') {
                console.log('Returning from roster management to development modal...');
                document.getElementById('developmentModal').classList.remove('hidden');
            } else {
                // Default: return to Season End Modal
                console.log('Returning from roster management to Season End modal...');
                document.getElementById('seasonEndModal').classList.remove('hidden');
            }
        }
        
        function closeRosterManagementToGame() {
            document.getElementById('rosterModal').classList.add('hidden');
            saveGameState();
            updateUI();
            
            // Don't show any modal - return to game
            console.log('Closed roster management, returning to game');
        }
        
        function closeRosterManagementDynamic() {
            console.log('üîÑ closeRosterManagementDynamic called, context:', rosterManagementReturnContext);
            if (rosterManagementReturnContext === 'game') {
                closeRosterManagementToGame();
            } else {
                closeRosterManagement();
            }
        }

        // Resume offseason flow ‚Äî called when user closes roster management during offseason
        function openTradeScreenFromRoster() {
            // Store that we came from roster management
            window.returnToRosterManagement = true;
            
            // Hide roster modal
            document.getElementById('rosterModal').classList.add('hidden');
            
            // Open trade screen
            getTradeController().openTradeScreen();
        }
        
        // Open Roster Management Hub (during regular season)
        function openRosterManagementHub() {
            console.log('üë• Opening Roster Management Hub');
            
            // Set context so we return to game (not season end modal)
            rosterManagementReturnContext = 'game';
            
            // Open the roster modal
            document.getElementById('rosterModal').classList.remove('hidden');
            
            // Update displays
            getRosterController().updateRosterDisplay();
            filterFreeAgents();
        }

        function filterFreeAgents() {
            const positionFilter = document.getElementById('positionFilter').value;
            const tierFilter = document.getElementById('tierFilter').value;
            
            currentFreeAgentFilter.position = positionFilter;
            currentFreeAgentFilter.tier = tierFilter;
            
            displayFreeAgents();
        }

        function sortFreeAgents(sortBy) {
            currentFreeAgentFilter.sort = sortBy;
            displayFreeAgents();
        }

        function displayFreeAgents() {
            let filtered = [...gameState.freeAgents];
            
            // Apply position filter
            if (currentFreeAgentFilter.position !== 'ALL') {
                filtered = filtered.filter(p => p.position === currentFreeAgentFilter.position);
            }
            
            // Apply tier filter (based on rating ranges)
            if (currentFreeAgentFilter.tier !== 'ALL') {
                const tier = parseInt(currentFreeAgentFilter.tier);
                if (tier === 1) {
                    filtered = filtered.filter(p => p.rating >= 70 && p.rating <= 95);
                } else if (tier === 2) {
                    filtered = filtered.filter(p => p.rating >= 60 && p.rating <= 85);
                } else if (tier === 3) {
                    filtered = filtered.filter(p => p.rating >= 50 && p.rating <= 75);
                }
            }
            
            // Apply sorting
            if (currentFreeAgentFilter.sort === 'rating') {
                filtered.sort((a, b) => b.rating - a.rating);
            } else if (currentFreeAgentFilter.sort === 'age') {
                filtered.sort((a, b) => a.age - b.age);
            }
            
            // Limit to top 50 for performance
            filtered = filtered.slice(0, 50);
            
            const userTeam = getUserTeam();
            const rosterFull = userTeam.roster.length >= 15;
            const remainingCap = SalaryCapEngine.getRemainingCap(userTeam);
            
            const freeAgentsHtml = filtered.map(player => {
                const canAfford = player.salary <= remainingCap;
                const canSign = !rosterFull && canAfford;
                
                // Ensure player has contract info
                if (!player.contractYears) {
                    player.contractYears = TeamFactory.determineContractLength(player.age, player.rating);
                    player.originalContractLength = player.contractYears;
                }
                
                return UIRenderer.freeAgentCard({ player, canSign, canAfford, rosterFull, getRatingColor, formatCurrency });
            }).join('');
            
            document.getElementById('freeAgentsList').innerHTML = freeAgentsHtml || '<p style="text-align: center; opacity: 0.7;">No free agents match filters</p>';
        }

        /**
         * Generate position breakdown HTML for a roster
         * @param {Array} roster - Array of player objects
         * @param {string} title - Optional title (default: "Position Breakdown")
         * @returns {string} HTML string
         */
        // Make roster management functions globally accessible
        // ===== PLAYER DEVELOPMENT DISPLAY =====
        
        // Keep old function for compatibility
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Expired contract decision handlers
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FREE AGENCY SYSTEM - Player gets priority access to free agents
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function buildCurrentRosterDisplay(team) {
            if (!team.roster || team.roster.length === 0) {
                return '<p style="text-align: center; opacity: 0.6; padding: 20px;">No players on roster</p>';
            }
            
            const sortedRoster = [...team.roster].sort((a, b) => b.rating - a.rating);
            const byPosition = {
                'PG': sortedRoster.filter(p => p.position === 'PG'),
                'SG': sortedRoster.filter(p => p.position === 'SG'),
                'SF': sortedRoster.filter(p => p.position === 'SF'),
                'PF': sortedRoster.filter(p => p.position === 'PF'),
                'C': sortedRoster.filter(p => p.position === 'C')
            };
            
            const teamEffCap = SalaryCapEngine.getEffectiveCap(team);
            const baseCap = SalaryCapEngine.getSalaryCap(team.tier);
            const totalSalary = SalaryCapEngine.calculateTeamSalary(team);
            
            return UIRenderer.currentRosterSidebar({
                roster: team.roster, byPosition, teamEffCap, baseCap,
                tier: team.tier, totalSalary, formatCurrency
            });
        }
        
        // Shared helper: builds the free agency player list HTML using UIRenderer
        function isOnWatchList(playerId) { return getRosterController()._isOnWatchList(playerId); }
        function buildFAListHTML(formerPlayers, otherPlayers, hiddenCount, positionFilter, selectedIds) {
            const userTeam = getUserTeam();
            const selected = selectedIds || new Set();
            
            if (gameState.freeAgents.length === 0) {
                return UIRenderer.faEmptyState();
            }
            
            const shownCount = formerPlayers.length + otherPlayers.length;
            let html = UIRenderer.faListHeader({
                totalCount: gameState.freeAgents.length,
                shownCount, formerCount: formerPlayers.length, hiddenCount,
                positionFilter
            });
            
            html += UIRenderer.faTableHeader();
            
            // Former players
            const filteredFormer = positionFilter && positionFilter !== 'ALL'
                ? formerPlayers.filter(p => p.position === positionFilter) : formerPlayers;
            filteredFormer.forEach(player => {
                const fit = ScoutingEngine.calculateTeamFit(player, userTeam, userTeam.coach);
                html += UIRenderer.faFormerPlayerRow({
                    player, isChecked: selected.has(String(player.id)),
                    fitGrade: fit.grade, gradeColor: ScoutingEngine.gradeColor(fit.grade),
                    watched: isOnWatchList(player.id),
                    marketDisplay: formatMarketDisplay(player, userTeam.tier),
                    teamName: userTeam.name
                });
            });
            
            // Separate watched from unwatched
            const watchedFAs = otherPlayers.filter(p => isOnWatchList(p.id));
            const unwatchedFAs = otherPlayers.filter(p => !isOnWatchList(p.id));
            
            if (watchedFAs.length > 0) {
                html += UIRenderer.faSectionDivider({ label: 'üîç WATCHED PLAYERS', count: watchedFAs.length, color: '#bb86fc', borderColor: 'rgba(155,89,182,0.4)' });
                watchedFAs.forEach(player => {
                    const previousTeam = player.previousTeamId ? getTeamById(player.previousTeamId) : null;
                    const previousTeamName = previousTeam ? previousTeam.name : (player.isCollegeGrad ? `üéì ${player.college}` : 'N/A');
                    const fit = ScoutingEngine.calculateTeamFit(player, userTeam, userTeam.coach);
                    player._marketDisplay = formatMarketDisplay(player, userTeam.tier);
                    html += UIRenderer.faPlayerRow({
                        player, isChecked: selected.has(String(player.id)),
                        fitGrade: fit.grade, gradeColor: ScoutingEngine.gradeColor(fit.grade),
                        previousTeamName, isWatched: true
                    });
                });
            }
            
            if (unwatchedFAs.length > 0) {
                const label = positionFilter && positionFilter !== 'ALL'
                    ? `OTHER AVAILABLE FREE AGENTS (${positionFilter})`
                    : 'OTHER AVAILABLE FREE AGENTS';
                html += UIRenderer.faSectionDivider({ label, count: unwatchedFAs.length, color: 'rgba(255,255,255,0.7)', borderColor: 'rgba(255,255,255,0.2)' });
                if (hiddenCount > 0) {
                    html += `<tr><td colspan="8" style="padding: 5px 15px; font-size: 0.85em; opacity: 0.6; text-align: center;">${hiddenCount} more lower-rated players not shown</td></tr>`;
                }
            }
            
            unwatchedFAs.forEach(player => {
                const previousTeam = player.previousTeamId ? getTeamById(player.previousTeamId) : null;
                const previousTeamName = previousTeam ? previousTeam.name : (player.isCollegeGrad ? `üéì ${player.college}` : 'N/A');
                const fit = ScoutingEngine.calculateTeamFit(player, userTeam, userTeam.coach);
                player._marketDisplay = formatMarketDisplay(player, userTeam.tier);
                html += UIRenderer.faPlayerRow({
                    player, isChecked: selected.has(String(player.id)),
                    fitGrade: fit.grade, gradeColor: ScoutingEngine.gradeColor(fit.grade),
                    previousTeamName, isWatched: false
                });
            });
            
            html += '</tbody></table>';
            return html;
        }

        function showFreeAgencyModal() {
            const userTeam = getUserTeam();
            const capSpace = SalaryCapEngine.getRemainingCap(userTeam);
            
            window.faSelectedIds = new Set();
            
            document.getElementById('faCapSpace').textContent = SalaryCapEngine.formatCurrency(capSpace);
            document.getElementById('faCurrentRoster').innerHTML = buildCurrentRosterDisplay(userTeam);
            
            const formerPlayers = gameState.freeAgents.filter(p => p.previousTeamId && p.previousTeamId === userTeam.id);
            const otherPlayers = gameState.freeAgents.filter(p => !p.previousTeamId || p.previousTeamId !== userTeam.id);
            
            // Pre-select former players
            formerPlayers.forEach(p => window.faSelectedIds.add(String(p.id)));
            
            formerPlayers.sort((a, b) => b.rating - a.rating);
            otherPlayers.sort((a, b) => b.rating - a.rating);
            
            const MAX_OTHER_PLAYERS = 150;
            const displayedOtherPlayers = otherPlayers.slice(0, MAX_OTHER_PLAYERS);
            const hiddenCount = otherPlayers.length - displayedOtherPlayers.length;
            
            // Empty state
            if (gameState.freeAgents.length === 0) {
                document.getElementById('freeAgencyPlayersList').innerHTML = UIRenderer.faEmptyState();
                document.getElementById('submitOffersBtn').disabled = true;
                document.getElementById('freeAgencyModal').classList.remove('hidden');
                return;
            }
            
            const html = buildFAListHTML(formerPlayers, displayedOtherPlayers, hiddenCount, 'ALL', window.faSelectedIds);
            document.getElementById('freeAgencyPlayersList').innerHTML = html;
            
            document.getElementById('freeAgencyModal').classList.remove('hidden');
            
            window.faFormerPlayers = formerPlayers;
            window.faOtherPlayers = displayedOtherPlayers;
            window.faHiddenCount = hiddenCount;
            
            if (formerPlayers.length > 0) {
                updateOffersPanel();
            }
            updateOfferTally();
        }
        
        function filterFreeAgentsByPosition() {
            const positionFilter = document.getElementById('faPositionFilter').value;
            
            // Sync any visible checkbox changes into the persistent Set before rebuild
            const selected = window.faSelectedIds || new Set();
            gameState.freeAgents.forEach(fa => {
                const cb = document.getElementById(`fa_${fa.id}`);
                if (cb) {
                    if (cb.checked) selected.add(String(fa.id));
                    else selected.delete(String(fa.id));
                }
            });
            
            const formerPlayers = window.faFormerPlayers || [];
            const allOtherPlayers = window.faOtherPlayers || [];
            
            let filteredOtherPlayers = allOtherPlayers;
            if (positionFilter !== 'ALL') {
                filteredOtherPlayers = allOtherPlayers.filter(p => p.position === positionFilter);
            }
            
            const html = buildFAListHTML(formerPlayers, filteredOtherPlayers, window.faHiddenCount || 0, positionFilter, selected);
            document.getElementById('freeAgencyPlayersList').innerHTML = html;
            
            updateOffersPanel();
            updateOfferTally();
        }
        
        function toggleFreeAgentSelection(playerId) {
            const checkbox = document.getElementById(`fa_${playerId}`);
            const idStr = String(playerId);
            
            // Update the persistent selection Set
            if (checkbox && checkbox.checked) {
                window.faSelectedIds.add(idStr);
            } else {
                window.faSelectedIds.delete(idStr);
            }
            
            // Update offers panel and tally
            updateOffersPanel();
            updateOfferTally();
        }
        
        function updateOfferTally() {
            const userTeam = getUserTeam();
            if (!userTeam) return;
            
            const selected = window.faSelectedIds || new Set();
            const selectedPlayers = gameState.freeAgents.filter(fa => selected.has(String(fa.id)));
            
            const tallyEl = document.getElementById('faOfferTally');
            if (!tallyEl) return;
            
            if (selectedPlayers.length === 0) {
                tallyEl.style.display = 'none';
                return;
            }
            
            tallyEl.style.display = 'block';
            
            // Calculate estimated cost (market value for each selected player)
            const estCost = selectedPlayers.reduce((sum, p) => sum + TeamFactory.getMarketValue(p, userTeam.tier), 0);
            const capSpace = SalaryCapEngine.getRemainingCap(userTeam);
            const remaining = capSpace - estCost;
            
            document.getElementById('faOfferCount').textContent = selectedPlayers.length;
            document.getElementById('faOfferTotal').textContent = SalaryCapEngine.formatCurrency(estCost);
            
            const remEl = document.getElementById('faOfferRemaining');
            remEl.textContent = SalaryCapEngine.formatCurrency(remaining);
            remEl.style.color = remaining >= 0 ? '#34a853' : '#ea4335';
        }
        
        function updateOffersPanel() {
            const userTeam = getUserTeam();
            const selected = window.faSelectedIds || new Set();
            const selectedPlayers = gameState.freeAgents.filter(fa => selected.has(String(fa.id)));
            
            const offerCount = selectedPlayers.length;
            document.getElementById('offerCount').textContent = offerCount;
            
            if (offerCount === 0) {
                document.getElementById('selectedOffersPanel').style.display = 'none';
                document.getElementById('submitOffersBtn').disabled = true;
                return;
            }
            
            document.getElementById('selectedOffersPanel').style.display = 'block';
            document.getElementById('submitOffersBtn').disabled = false;
            
            let html = '';
            selectedPlayers.forEach(player => {
                const marketValue = TeamFactory.getMarketValue(player, userTeam.tier);
                const playerNatTier = TeamFactory.getPlayerNaturalTier(player);
                const minOffer = Math.round(marketValue * 0.8);
                const maxOffer = Math.round(marketValue * 1.2);
                const suggestedYears = TeamFactory.determineContractLength(player.age, player.rating);
                const isFormerPlayer = player.previousTeamId === userTeam.id;
                const isAboveTier = playerNatTier < userTeam.tier;
                
                player._faMarketValue = marketValue;
                player._faMinOffer = minOffer;
                player._faMaxOffer = maxOffer;
                
                html += UIRenderer.faOfferCard({
                    player, marketValue, minOffer, maxOffer, suggestedYears,
                    isFormerPlayer, isAboveTier, playerNatTier, userTier: userTeam.tier,
                    formatCurrency, formatMarketDisplay
                });
            });
            
            document.getElementById('offersList').innerHTML = html;
        }
        
        function submitFreeAgencyOffers() {
            const userTeam = getUserTeam();
            const selected = window.faSelectedIds || new Set();
            const selectedPlayers = gameState.freeAgents.filter(fa => selected.has(String(fa.id)));
            
            if (selectedPlayers.length === 0) {
                alert('Please select at least one player to make an offer to.');
                return;
            }
            
            // Validate and collect offers
            gameState.userFreeAgencyOffers = [];
            let totalCommitment = 0;
            
            for (const player of selectedPlayers) {
                const salaryInput = document.getElementById(`offer_salary_${player.id}`);
                const yearsInput = document.getElementById(`offer_years_${player.id}`);
                
                const offeredSalary = parseInt(salaryInput.value);
                const offeredYears = parseInt(yearsInput.value);
                
                // Use the stored market value from when we generated the offer panel
                // This avoids random variation from calling TeamFactory.generateSalary() again
                const minOffer = player._faMinOffer;
                const maxOffer = player._faMaxOffer;
                
                if (offeredSalary < minOffer || offeredSalary > maxOffer) {
                    alert(`Your offer to ${player.name} is outside the acceptable range (${SalaryCapEngine.formatCurrency(minOffer)} - ${SalaryCapEngine.formatCurrency(maxOffer)})`);
                    return;
                }
                
                totalCommitment += offeredSalary;
                
                gameState.userFreeAgencyOffers.push({
                    teamId: userTeam.id,
                    playerId: player.id,
                    salary: offeredSalary,
                    years: offeredYears,
                    tier: userTeam.tier,
                    teamRating: userTeam.rating,
                    teamSuccess: userTeam.wins / (userTeam.wins + userTeam.losses || 1)
                });
            }
            
            // Check cap space (only first year counts)
            const capSpace = SalaryCapEngine.getRemainingCap(userTeam);
            if (totalCommitment > capSpace) {
                alert(`Your offers total ${SalaryCapEngine.formatCurrency(totalCommitment)}, but you only have ${SalaryCapEngine.formatCurrency(capSpace)} in cap space.\n\nReduce your offers or target fewer players.`);
                return;
            }
            
            console.log(`‚úÖ User submitted ${gameState.userFreeAgencyOffers.length} offers`);
            
            // Close modal and process
            document.getElementById('freeAgencyModal').classList.add('hidden');
            
            // Generate AI offers and process decisions
            processFreeAgency();
        }
        
        function skipFreeAgency() {
            if (confirm('Are you sure you want to skip free agency? You won\'t be able to sign any free agents this off-season.')) {
                console.log('‚è≠Ô∏è User skipped free agency');
                document.getElementById('freeAgencyModal').classList.add('hidden');
                
                // Let AI sign normally, then check roster
                getOffseasonController().runAISigningAndContinue();
            }
        }
        
        function processFreeAgency() {
            console.log('ü§ñ Processing free agency...');
            
            // Step 1: Generate AI offers
            generateAIFreeAgencyOffers();
            
            // Step 2: Process player decisions
            const results = processFreeAgentDecisions();
            
            // Step 3: Execute signings
            executeFreeAgencySignings(results);
            
            // Step 4: Show results
            showFreeAgencyResults(results);
        }
        
        function generateAIFreeAgencyOffers() {
            const userTeam = getUserTeam();
            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
            const aiTeams = allTeams.filter(t => t.id !== userTeam.id);
            
            gameState.aiFreeAgencyOffers = FreeAgencyEngine.generateAIOffers(
                { freeAgents: gameState.freeAgents, aiTeams },
                { TeamFactory, SalaryCapEngine }
            );
            
            console.log(`  AI teams made ${gameState.aiFreeAgencyOffers.length} offers to free agents`);
        }
        
        function processFreeAgentDecisions() {
            const userTeam = getUserTeam();
            
            return FreeAgencyEngine.processDecisions(
                {
                    freeAgents: gameState.freeAgents,
                    userOffers: gameState.userFreeAgencyOffers,
                    aiOffers: gameState.aiFreeAgencyOffers,
                    userTeamId: userTeam.id
                },
                { SalaryCapEngine }
            );
        }
        
        function executeFreeAgencySignings(results) {
            FreeAgencyEngine.executeSignings({
                results,
                freeAgentPool: gameState.freeAgents,
                getTeamById
            });
        }
        
        function showFreeAgencyResults(results) {
            document.getElementById('freeAgencyResultsContent').innerHTML = UIRenderer.freeAgencyResults({
                results, formatCurrency, getTeamById,
                userOffers: gameState.userFreeAgencyOffers
            });
            document.getElementById('freeAgencyResultsModal').classList.remove('hidden');
        }
        
        function continueFreeAgency() {
            document.getElementById('freeAgencyResultsModal').classList.add('hidden');
            
            // Now let AI teams fill remaining needs from leftover free agents
            console.log('ü§ñ AI teams filling remaining roster needs...');
            aiSigningPhase();
            
            // Then proceed to roster compliance check
            getOffseasonController().checkRosterComplianceAndContinue();
        }
        
        // Make free agency functions globally accessible
        // Step 4.5: Check roster compliance (salary cap + minimum roster)
        // Show modal forcing user to fix roster issues
        function openRosterManagementFromCompliance() {
            // Set return context so closeRosterManagement knows where to go back
            rosterManagementReturnContext = 'compliance';
            document.getElementById('complianceModal').classList.add('hidden');
            openRosterManagement();
        }
        
        function recheckRosterCompliance() {
            // User clicked "Ready to Continue" - check again
            document.getElementById('complianceModal').classList.add('hidden');
            getOffseasonController().checkRosterComplianceAndContinue();
        }
        
        // ===== COACH MANAGEMENT SYSTEM =====
        
        let coachMarketPool = []; // Available free agent coaches
        
        function openCoachManagement() {
            const userTeam = getUserTeam();
            if (!userTeam) return;
            const coach = userTeam.coach;
            const synergy = CoachEngine.calculateSynergy(coach, userTeam.roster);
            
            let coachSection = '';
            if (coach) {
                coachSection = buildCurrentCoachHTML(coach, synergy);
            } else {
                coachSection = UIRenderer.noCoachWarning();
            }
            
            document.getElementById('coachModalContent').innerHTML = UIRenderer.coachManagementPage({
                coachSection, hasCoach: !!coach
            });
            document.getElementById('coachModal').classList.remove('hidden');
        }
        
        function buildCurrentCoachHTML(coach, synergy) {
            let traitBars = '';
            for (const [key, def] of Object.entries(CoachEngine.TRAITS)) {
                const val = coach.traits[key] || 50;
                const color = CoachEngine.getTraitColor(val);
                const label = CoachEngine.getTraitLabel(key, val);
                traitBars += UIRenderer.coachTraitBar({ def, val, color, label });
            }
            
            return UIRenderer.currentCoachDisplay({
                coach: { ...coach, overallColor: CoachEngine.getOverallColor(coach.overall) },
                synergy, traitBars, formatCurrency
            });
        }
        
        function showCoachMarket() {
            const userTeam = getUserTeam();
            if (!userTeam) return;
            
            // Generate pool if not already done
            if (coachMarketPool.length === 0) {
                coachMarketPool = CoachEngine.generateCoachPool(10, userTeam.tier);
            }
            
            // Also collect poachable coaches from other teams in same tier
            const tierTeams = gameState.getTeamsByTier(userTeam.tier);
            const poachable = tierTeams
                .filter(t => t.id !== userTeam.id && t.coach)
                .map(t => ({ ...t.coach, _fromTeam: t.name, _fromTeamId: t.id }))
                .sort((a, b) => b.overall - a.overall)
                .slice(0, 8);
            
            document.getElementById('coachMarketContainer').innerHTML = UIRenderer.coachMarketContainer({
                freeAgentCount: coachMarketPool.length,
                poachableCount: poachable.length,
                freeAgentListHTML: buildCoachListHTML(coachMarketPool, userTeam, false),
                poachListHTML: buildCoachListHTML(poachable, userTeam, true)
            });
        }
        
        function showCoachTab(tab) {
            const faList = document.getElementById('freeAgentCoachList');
            const poachList = document.getElementById('poachCoachList');
            const faTab = document.getElementById('freeAgentCoachTab');
            const poachTab = document.getElementById('poachCoachTab');
            
            if (tab === 'freeAgent') {
                faList.style.display = 'block';
                poachList.style.display = 'none';
                faTab.style.background = 'linear-gradient(135deg, #34a853 0%, #2e7d32 100%)';
                poachTab.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            } else {
                faList.style.display = 'none';
                poachList.style.display = 'block';
                poachTab.style.background = 'linear-gradient(135deg, #34a853 0%, #2e7d32 100%)';
                faTab.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
        }
        
        function buildCoachListHTML(coaches, userTeam, isPoach) {
            if (coaches.length === 0) return '<div style="text-align: center; padding: 20px; opacity: 0.6;">No coaches available</div>';
            
            let html = '<div style="max-height: 500px; overflow-y: auto;">';
            for (const coach of coaches) {
                const synergy = CoachEngine.calculateSynergy(coach, userTeam.roster);
                const buyout = isPoach ? CoachEngine.calculateBuyoutCost(coach) : 0;
                const topTraits = Object.entries(coach.traits)
                    .sort(([,a],[,b]) => b - a)
                    .slice(0, 3)
                    .map(([key, val]) => `${CoachEngine.TRAITS[key].icon} ${CoachEngine.TRAITS[key].name}: ${val}`)
                    .join(' ¬∑ ');
                
                html += UIRenderer.coachMarketCard({ coach, synergy, topTraits, isPoach, buyout, formatCurrency, CoachEngine });
            }
            html += '</div>';
            return html;
        }
        
        function hireCoach(coachId, isPoach) {
            const userTeam = getUserTeam();
            if (!userTeam) return;
            
            let newCoach = null;
            
            if (isPoach) {
                // Find coach from another team
                const tierTeams = gameState.getTeamsByTier(userTeam.tier);
                const sourceTeam = tierTeams.find(t => t.coach && t.coach.id === coachId);
                if (!sourceTeam) { alert('Coach no longer available.'); return; }
                
                const buyout = CoachEngine.calculateBuyoutCost(sourceTeam.coach);
                if (!confirm(`Poach ${sourceTeam.coach.name} from ${sourceTeam.name}?\n\nBuyout cost: ${SalaryCapEngine.formatCurrency(buyout)}\nSalary: ${SalaryCapEngine.formatCurrency(sourceTeam.coach.salary)}/yr\n\nThis will remove their coach and may affect their performance.`)) return;
                
                newCoach = sourceTeam.coach;
                // Give the source team a replacement coach (lower quality)
                sourceTeam.coach = CoachEngine.generateCoach(sourceTeam.tier);
                sourceTeam.coach.overall = Math.max(35, sourceTeam.coach.overall - 10); // Interim coach penalty
                sourceTeam.coach.teamId = sourceTeam.id;
                sourceTeam.coach.archetype = 'Interim ' + sourceTeam.coach.archetype;
                console.log(`üîÑ ${sourceTeam.name} assigned interim coach: ${sourceTeam.coach.name}`);
            } else {
                // Find from free agent pool
                newCoach = coachMarketPool.find(c => c.id === coachId);
                if (!newCoach) { alert('Coach no longer available.'); return; }
                
                if (!confirm(`Hire ${newCoach.name}?\n\nOverall: ${newCoach.overall}\nSalary: ${SalaryCapEngine.formatCurrency(newCoach.salary)}/yr √ó ${newCoach.contractYears} years\nStyle: ${newCoach.archetype}`)) return;
                
                // Remove from pool
                coachMarketPool = coachMarketPool.filter(c => c.id !== coachId);
            }
            
            // If team already has a coach, release them
            if (userTeam.coach) {
                console.log(`üö™ Released coach: ${userTeam.coach.name}`);
                userTeam.coach.teamId = null;
            }
            
            // Assign new coach
            newCoach.teamId = userTeam.id;
            newCoach.tier = userTeam.tier;
            userTeam.coach = newCoach;
            
            console.log(`‚úÖ Hired coach: ${newCoach.name} (${newCoach.overall} OVR) for ${userTeam.name}`);
            
            eventBus.emit(GameEvents.TEAM_COACH_HIRED, {
                teamId: userTeam.id,
                teamName: userTeam.name,
                coachName: newCoach.name,
                coachOverall: newCoach.overall,
                archetype: newCoach.archetype,
                isPoach: isPoach
            });
            
            saveGameState();
            updateUI();
            openCoachManagement(); // Refresh the modal
        }
        
        function fireCoach() {
            const userTeam = getUserTeam();
            if (!userTeam || !userTeam.coach) return;
            
            const coach = userTeam.coach;
            const severance = Math.round(coach.salary * Math.max(1, coach.contractYears) * 0.5);
            
            if (!confirm(`Fire ${coach.name}?\n\nSeverance cost: ${SalaryCapEngine.formatCurrency(severance)}\nRemaining contract: ${coach.contractYears} year(s)\n\nYour team will operate without a head coach until you hire a replacement, which will negatively affect performance.`)) return;
            
            console.log(`üö™ Fired coach: ${coach.name}`);
            
            eventBus.emit(GameEvents.TEAM_COACH_FIRED, {
                teamId: userTeam.id,
                teamName: userTeam.name,
                coachName: coach.name,
                coachOverall: coach.overall,
                severance: severance
            });
            
            coach.teamId = null;
            userTeam.coach = null;
            
            saveGameState();
            updateUI();
            openCoachManagement();
        }
        
        function closeCoachModal() {
            document.getElementById('coachModal').classList.add('hidden');
        }
        
        // ===== PLAYER ATTRIBUTE DISPLAY =====
        
        function togglePlayerAttributes(playerId) {
            const container = document.getElementById(`playerAttrs_${playerId}`);
            if (!container) return;
            
            if (container.style.display !== 'none') {
                container.style.display = 'none';
                return;
            }
            
            const userTeam = getUserTeam();
            const player = userTeam.roster.find(p => p.id === playerId);
            if (!player) return;
            
            // Ensure attributes exist
            PlayerAttributes.ensureAttributes(player);
            
            container.innerHTML = UIRenderer.playerAttributesPanel({ player, PlayerAttributes });
            container.style.display = 'block';
        }
        
        // ===== TRADE SYSTEM =====
        
        let currentTrade = {
            aiTeamId: null,
            userGives: [],  // Array of player IDs
            userReceives: [], // Array of player IDs
            userGivesPicks: [], // Array of {originalTeamId, year, round}
            userReceivesPicks: [] // Array of {originalTeamId, year, round}
        };

        // Make pick toggle functions globally accessible
        function getTeamById(teamId) {
            return [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams]
                .find(t => t.id === teamId);
        }
        
        // Make trade functions globally accessible
        // ===== AI TRADE PROPOSALS (PHASE 3) =====
        
        // Make AI trade functions globally accessible
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INJURY MODAL UI
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let pendingInjuryDecision = null;
        
        // Process the next injury in the pending queue
        function showNextInjuryModal() {
            if (!gameState.pendingInjuries || gameState.pendingInjuries.length === 0) return;
            const next = gameState.pendingInjuries[0];
            
            // Find the actual team object
            const allTeams = [...gameState.tier1Teams, ...gameState.tier2Teams, ...gameState.tier3Teams];
            const team = allTeams.find(t => t.id === next.team?.id) || next.team;
            
            // Find the actual player on the team
            const player = team.roster ? team.roster.find(p => p.id === next.player?.id) || next.player : next.player;
            
            showInjuryModal(team, player, next.injury);
        }
        
        function showInjuryModal(team, player, injury) {
            pendingInjuryDecision = { team, player, injury, decision: null };
            
            const userTeam = getUserTeam();
            const isUserTeam = team.id === userTeam.id;
            
            // Render details header via UIRenderer
            document.getElementById('injuryDetails').innerHTML = UIRenderer.injuryDetails({ player, team, injury });
            
            // Build options based on team type and severity
            let optionsHtml = '';
            
            if (!isUserTeam) {
                // AI team injury - auto-decide and just inform user
                const aiDecision = injury.canPlayThrough && Math.random() < 0.3 ? 'playThrough' : 'rest';
                InjuryEngine.applyInjury(player, injury, aiDecision);
                
                optionsHtml = UIRenderer.injuryAiDecision({ team, player, aiDecision, injury });
                
                document.getElementById('injuryConfirmBtn').textContent = 'Continue';
                document.getElementById('injuryConfirmBtn').onclick = () => {
                    if (gameState.pendingInjuries && gameState.pendingInjuries.length > 0) {
                        gameState.pendingInjuries.shift();
                    }
                    document.getElementById('injuryModal').classList.add('hidden');
                    pendingInjuryDecision = null;
                    if (gameState.pendingInjuries && gameState.pendingInjuries.length > 0) {
                        showNextInjuryModal();
                    }
                };
            } else {
                // User team injury - present options
                if (injury.canPlayThrough) {
                    optionsHtml = UIRenderer.injuryUserOptions({ player, injury });
                } else {
                    // Severe/season-ending - no choice
                    const dpeEligible = injury.allowsDPE && player.salary > getDPEThreshold(team.tier);
                    const dpeAmount = dpeEligible ? Math.min(player.salary * 0.5, getDPEAmount(team.tier)) : 0;
                    
                    optionsHtml = UIRenderer.injurySevereOptions({ player, injury, formatCurrency, dpeEligible, dpeAmount });
                    
                    InjuryEngine.applyInjury(player, injury, 'rest');
                    
                    if (dpeEligible) {
                        grantDPE(team, player);
                    }
                }
                
                document.getElementById('injuryConfirmBtn').textContent = injury.canPlayThrough ? 'Confirm Decision' : 'Continue';
                document.getElementById('injuryConfirmBtn').onclick = () => {
                    if (injury.canPlayThrough && !pendingInjuryDecision.decision) {
                        alert('Please select a treatment option.');
                        return;
                    }
                    
                    if (pendingInjuryDecision.decision) {
                        InjuryEngine.applyInjury(player, injury, pendingInjuryDecision.decision);
                    }
                    
                    if (gameState.pendingInjuries && gameState.pendingInjuries.length > 0) {
                        gameState.pendingInjuries.shift();
                    }
                    
                    document.getElementById('injuryModal').classList.add('hidden');
                    pendingInjuryDecision = null;
                    
                    if (gameState.pendingInjuries && gameState.pendingInjuries.length > 0) {
                        showNextInjuryModal();
                    }
                };
            }
            
            document.getElementById('injuryOptions').innerHTML = optionsHtml;
            document.getElementById('injuryModal').classList.remove('hidden');
        }
        
        function selectInjuryOption(option) {
            pendingInjuryDecision.decision = option;
            document.querySelectorAll('.injury-option-btn').forEach(btn => {
                btn.style.opacity = btn.dataset.option === option ? '1' : '0.5';
                btn.style.border = btn.dataset.option === option ? '2px solid #667eea' : '2px solid transparent';
            });
        }
        
        // DPE thresholds (roughly 50% of tier's mid-level exception equivalent)
        function getDPEThreshold(tier) {
            if (tier === 1) return 6000000;  // $6M
            if (tier === 2) return 600000;   // $600K
            return 75000;                     // $75K
        }
        
        function getDPEAmount(tier) {
            if (tier === 1) return 6000000;  // Max $6M exception
            if (tier === 2) return 600000;   // Max $600K exception
            return 75000;                     // Max $75K exception
        }
        
        function grantDPE(team, injuredPlayer) {
            const dpeAmount = Math.min(injuredPlayer.salary * 0.5, getDPEAmount(team.tier));
            
            if (!team.dpe) team.dpe = [];
            team.dpe.push({
                player: injuredPlayer.name,
                amount: dpeAmount,
                expires: gameState.currentSeason
            });
            
            console.log(`üí∞ DPE granted to ${team.name}: ${SalaryCapEngine.formatCurrency(dpeAmount)} (${injuredPlayer.name})`);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CONTRACT DECISIONS MODAL
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let contractDecisionsState = {
            expiringPlayers: [],
            developmentLog: [],
            decisions: {} // playerId -> 'resign' | 'release'
        };
        
        // ===== DRAFT RESULTS DISPLAY =====
        
        let currentDraftResults = [];
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 2: OWNER MODE ‚Äî Offseason Financial Management
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Shows between roster compliance and season setup.
        // If Owner Mode is off, applies AI defaults and skips to season setup.
        // If Owner Mode is on, shows interactive management screen.
        
        // ‚îÄ‚îÄ‚îÄ HOOK INTO ADVANCE FINANCES ‚îÄ‚îÄ‚îÄ
        // Override advanceFinancialTransitions to include Phase 2 processing
        const _originalAdvanceFinancialTransitions = advanceFinancialTransitions;
        advanceFinancialTransitions = function(allTeams) {
            const userTeam = getUserTeam();
            allTeams.forEach(team => {
                FinanceEngine.ensureFinances(team);
                
                // AI teams: generate and auto-accept sponsors, set marketing
                if (!userTeam || team.id !== userTeam.id) {
                    OwnerEngine.generateSponsorOffers(team);
                    OwnerEngine.applyAIFinancialDefaults(team);
                }
                
                // Phase 2: Process sponsorships, arena, and marketing BEFORE revenue decay
                OwnerEngine.processSponsorships(team);
                OwnerEngine.processArenaEffects(team);
                OwnerEngine.processMarketingEffects(team, { formatCurrency: SalaryCapEngine.formatCurrency });
                
                // Then do the standard revenue decay/growth and fanbase evolution
                FinanceEngine.advanceFinances(team, { wins: team.wins || 0, losses: team.losses || 0 });
            });
        };
        
        // ‚îÄ‚îÄ‚îÄ OWNER MODE MODAL ‚îÄ‚îÄ‚îÄ
        // ‚îÄ‚îÄ‚îÄ OWNER MODE INTERACTION FUNCTIONS ‚îÄ‚îÄ‚îÄ
        
        function updateTicketPriceEffect(pct) {
            const el = document.getElementById('ticketPriceEffect');
            if (!el) return;
            el.innerHTML = UIRenderer.ticketPriceEffect({ pct });
        }
        
        // ‚îÄ‚îÄ‚îÄ OWNER MODE TOGGLE ‚îÄ‚îÄ‚îÄ
        // Step 5: Continue to Season Setup
        // Make draft functions globally accessible
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WINDOW EXPOSURES ‚Äî Functions called from HTML onclick handlers
        // Must be on window since game code runs inside _initGame wrapper
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Note: simDay, simWeek, simNextGame, finishSeason are wired by GMMode constructor
        // via btn.onclick = () => this.simulateDay() etc. No global functions needed.
        // Initialize immediately ‚Äî _initGame is called by module script after DOM is ready
        (async function() {
            try {
                console.log('üèÄ The Association v4.0 - Phase 3');
                console.log('Initializing GameState class...');
                
                // Load saved game via StorageEngine (IndexedDB ‚Üí localStorage fallback)
                console.log('üìÇ Attempting to load save via StorageEngine...');
                const savedData = await StorageEngine.load();
                console.log('üìÇ StorageEngine.load() returned:', savedData ? `${Math.round(savedData.length/1024)}KB of data` : 'null (no save found)');
                
                if (savedData) {
                    // Load saved game
                    try {
                        const parsed = JSON.parse(savedData);
                        if (parsed.gameVersion && parseFloat(parsed.gameVersion) >= 4.0) {
                            // New format
                            gameState = GameState.deserialize(savedData);
                        } else {
                            // Old format - need to migrate
                            gameState = migrateToGameStateClass(parsed);
                        }
                        gameState = createGameStateProxy(gameState);
                        console.log('‚úÖ Loaded existing save');
                    } catch (error) {
                        console.error('Error loading save:', error);
                        gameState = createGameStateProxy(new GameState());
                    }
                } else {
                    // Fresh initialization for team selection
                    gameState = createGameStateProxy(new GameState());
                }
                
                // Determine if we have an existing game
                const hasExistingGame = !!(savedData && gameState.userTeamId);
                
                // Only initialize fresh teams for NEW games ‚Äî loaded saves already have them
                if (!hasExistingGame) {
                    console.log('üÜï New game ‚Äî generating fresh teams...');
                    gameState.tier1Teams = TeamFactory.initializeTierTeams(1, generateRoster);
                    gameState.tier2Teams = TeamFactory.initializeTierTeams(2, generateRoster);
                    gameState.tier3Teams = TeamFactory.initializeTierTeams(3, generateRoster);
                }
                
                console.log('Teams: T1=' + gameState.tier1Teams.length + 
                           ', T2=' + gameState.tier2Teams.length + 
                           ', T3=' + gameState.tier3Teams.length);
                
                // CRITICAL: Validate tier counts after loading
                if (hasExistingGame) {
                    console.log('Validating loaded tier counts...');
                    console.log('Loaded: T1=' + gameState.tier1Teams.length + ', T2=' + gameState.tier2Teams.length + ', T3=' + gameState.tier3Teams.length);
                    
                    if (gameState.tier1Teams.length !== 30 || gameState.tier2Teams.length !== 86 || gameState.tier3Teams.length !== 144) {
                        console.error('‚ö†Ô∏è CORRUPTED SAVE DETECTED! Tier counts are wrong.');
                        console.error('This save file has incorrect team counts and cannot be loaded.');
                        alert('Your save file has corrupted team counts. Please start a new game.\n\nT1: ' + gameState.tier1Teams.length + ' (should be 30)\nT2: ' + gameState.tier2Teams.length + ' (should be 86)\nT3: ' + gameState.tier3Teams.length + ' (should be 144)');
                        
                        // Reset to fresh state
                        localStorage.removeItem('gbslMultiTierGameState');
                        location.reload();
                        return;
                    }
                }
                
                if (hasExistingGame) {
                    document.getElementById('gameContainer').style.display = 'block';
                    document.getElementById('teamSelectionModal').classList.add('hidden');
                    updateUI();
                } else {
                    // Generate free agent pool for new games
                    gameState.freeAgents = generateFreeAgentPool();
                    // Show team selection modal
                    document.getElementById('teamSelectionModal').classList.remove('hidden');
                }
                
                
                // Initialize GM Mode (Phase 3)
                console.log('Initializing GMMode...');
                gmMode = new GMMode(gameState, simulationController, {
                    updateUI, updateStandings, updateNextGames,
                    showSeasonEnd: () => getGameSimController().showSeasonEnd(),
                    openRosterManagement, openTradeScreen: () => getTradeController().openTradeScreen(), saveGameState,
                    checkForAiTradeProposals: () => getTradeController().checkForAiTradeProposals(),
                    checkForInjuries: (...args) => InjuryEngine.checkForInjuries(...args),
                    updateInjuries: (team) => InjuryEngine.updateInjuries(team),
                    processFatigueAfterGame: (...args) => FatigueEngine.processAfterGame(...args),
                    formatCurrency, getUserTeam,
                    runAllStarWeekend,
                    applyFatigueAutoRest: (team, isPlayoffs) => FatigueEngine.applyAutoRest(team, isPlayoffs),
                    applyInjury, showNextInjuryModal, buildConferenceMap,
                    openRosterManagementHub,
                    resumeOffseason: () => getOffseasonController().resumeOffseason(),
                    eventBus, GameEvents, CalendarEngine, GameEngine
                });
                console.log('‚úÖ GMMode initialized');
                
                console.log('The Association Project loaded successfully!');
                console.log('Rosters: All teams have 12-15 players');
                console.log('Free Agents: ' + gameState.freeAgents.length + ' available');
            } catch(error) {
                alert('Error loading game: ' + error.message);
                console.error('Load error:', error);
                console.error('Stack:', error.stack);
            }
        })(); // end init IIFE

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GLOBAL EXPORTS ‚Äî HTML onclick handlers route to controllers
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        window.acceptAiTradeProposal = (...args) => getTradeController().acceptAiTradeProposal(...args);
        window.acceptSponsor = (...args) => getFinanceController().acceptSponsor(...args);
        window.addToWatchList = (...args) => getRosterController().addToWatchList(...args);
        window.advanceToNextSeason = (...args) => getOffseasonController().advanceToNextSeason(...args);
        window.applyScoutFilter = (...args) => getRosterController().applyScoutFilter(...args);
        window.closeCollegeGradResults = (...args) => getDraftController().closeCollegeGradResults(...args);
        window.closeDevelopmentSummary = (...args) => getOffseasonController().closeDevelopmentSummary(...args);
        window.closeDraftResults = (...args) => getDraftController().closeDraftResults(...args);
        window.closeLotteryModal = (...args) => getDraftController().closeLotteryModal(...args);
        window.closeScoutingModal = (...args) => getRosterController().closeScoutingModal(...args);
        window.closeSeasonEnd = (...args) => getGameSimController().closeSeasonEnd(...args);
        window.closeTradeScreen = (...args) => getTradeController().closeTradeScreen(...args);
        window.confirmOffseasonDecisions = (...args) => getOffseasonController().confirmOffseasonDecisions(...args);
        window.continueAfterChampionshipRound = (...args) => getGameSimController().continueAfterChampionshipRound(...args);
        window.continueAfterPostseason = (...args) => getOffseasonController().continueAfterPostseason(...args);
        window.dismissTransitionBriefing = (...args) => getFinanceController().dismissTransitionBriefing(...args);
        window.dropPlayer = (...args) => getRosterController().dropPlayer(...args);
        window.filterCollegeGrads = (...args) => getDraftController().filterCollegeGrads(...args);
        window.filterDraftProspects = (...args) => getDraftController().filterDraftProspects(...args);
        window.filterPipeline = (...args) => getRosterController().filterPipeline(...args);
        window.loadTradePartner = (...args) => getTradeController().loadTradePartner(...args);
        window.makeContractDecision = (...args) => getOffseasonController().makeContractDecision(...args);
        window.openFinanceDashboard = (...args) => getFinanceController().openFinanceDashboard(...args);
        window.openScoutingModal = (...args) => getRosterController().openScoutingModal(...args);
        window.proposeTrade = (...args) => getTradeController().proposeTrade(...args);
        window.rejectAiTradeProposal = (...args) => getTradeController().rejectAiTradeProposal(...args);
        window.toggleAiTradePlayer = (...args) => getTradeController().toggleAiTradePlayer(...args);
        window.toggleUserTradePlayer = (...args) => getTradeController().toggleUserTradePlayer(...args);
        window.releaseExpiredPlayer = (...args) => getOffseasonController().releaseExpiredPlayer(...args);
        window.removeFromWatchList = (...args) => getRosterController().removeFromWatchList(...args);
        window.renderScannerTab = (...args) => getRosterController()._renderScannerTab(...args);
        window.renderWatchListTab = (...args) => getRosterController().renderWatchListTab(...args);
        window.resignExpiredPlayer = (...args) => getOffseasonController().resignExpiredPlayer(...args);
        window.selectDraftProspect = (...args) => getDraftController().selectDraftProspect(...args);
        window.setMarketingBudget = (...args) => getFinanceController().setMarketingBudget(...args);
        window.showDraftRound = (...args) => getDraftController().showDraftRound(...args);
        window.showPlayerScoutDetail = (...args) => getRosterController().showPlayerScoutDetail(...args);
        window.showUserDraftPicks = (...args) => getDraftController().showUserDraftPicks(...args);
        window.signPlayer = (...args) => getRosterController().signPlayer(...args);
        window.signFreeAgent = (...args) => getRosterController().signPlayer(...args);
        window.simAllChampionshipRounds = (...args) => getGameSimController().simAllChampionshipRounds(...args);
        window.skipChampionshipPlayoffs = (...args) => getGameSimController().skipChampionshipPlayoffs(...args);
        window.skipCollegeGradFA = (...args) => getDraftController().skipCollegeGradFA(...args);
        window.submitCollegeGradOffers = (...args) => getDraftController().submitCollegeGradOffers(...args);
        window.switchScoutTab = (...args) => getRosterController().switchScoutTab(...args);
        window.toggleCollegeGradSelection = (...args) => getDraftController().toggleCollegeGradSelection(...args);
        window.toggleOwnerMode = (...args) => getFinanceController().toggleOwnerMode(...args);
        window.updateOwnerSpendingRatio = (...args) => getFinanceController().updateOwnerSpendingRatio(...args);
        window.updateSpendingRatio = (...args) => getFinanceController().updateSpendingRatio(...args);
        window.updateTicketPrice = (...args) => getFinanceController().updateTicketPrice(...args);
        window.updateTransitionSpending = (...args) => getFinanceController().updateTransitionSpending(...args);
        window.upgradeArena = (...args) => getFinanceController().upgradeArena(...args);
        window.watchGameClose = (...args) => getGameSimController().watchGameClose(...args);
        window.watchGameSetSpeed = (...args) => getGameSimController().watchGameSetSpeed(...args);
        window.watchGameSkip = (...args) => getGameSimController().watchGameSkip(...args);
        window.watchGameTogglePause = (...args) => getGameSimController().watchGameTogglePause(...args);
        window.watchNextGame = (...args) => getGameSimController().watchNextGame(...args);

        // ‚îÄ‚îÄ‚îÄ Local functions called from HTML ‚îÄ‚îÄ‚îÄ
        window.closeAllStarModal = closeAllStarModal;
        window.closeCoachModal = closeCoachModal;
        window.closeRosterManagementDynamic = closeRosterManagementDynamic;
        window.continueFreeAgency = continueFreeAgency;
        window.filterFreeAgents = filterFreeAgents;
        window.filterFreeAgentsByPosition = filterFreeAgentsByPosition;
        window.fireCoach = fireCoach;
        window.hireCoach = hireCoach;
        window.isOnWatchList = (playerId) => getRosterController()._isOnWatchList(playerId);
        window.openCalendarView = openCalendarView;
        window.openCoachManagement = openCoachManagement;
        window.formatCurrency = formatCurrency;
        window.calculateTeamSalary = calculateTeamSalary;
        window.determineContractLength = determineContractLength;
        window.generateSalary = generateSalary;
        window.openFranchiseHistory = openFranchiseHistory;
        window.openRosterManagement = openRosterManagement;
        window.openRosterManagementFromCompliance = openRosterManagementFromCompliance;
        window.openRosterManagementHub = openRosterManagementHub;
        window.openTradeScreenFromRoster = openTradeScreenFromRoster;
        window.recheckRosterCompliance = recheckRosterCompliance;
        window.resetGame = resetGame;
        window.selectInjuryOption = selectInjuryOption;
        window.selectTeam = selectTeam;
        window.selectTier = selectTier;
        window.showBoxScore = showBoxScore;
        window.showCalendarDayDetail = showCalendarDayDetail;
        window.showCoachMarket = showCoachMarket;
        window.showCoachTab = showCoachTab;
        window.skipFreeAgency = skipFreeAgency;
        window.sortFreeAgents = sortFreeAgents;
        window.submitFreeAgencyOffers = submitFreeAgencyOffers;
        window.toggleFreeAgentSelection = toggleFreeAgentSelection;
        window.togglePlayerAttributes = togglePlayerAttributes;
        window.toggleStandingsView = toggleStandingsView;
        window.viewTierStandings = viewTierStandings;

        // ‚îÄ‚îÄ‚îÄ Engine/class exports for cross-module access ‚îÄ‚îÄ‚îÄ
        window.SimBenchmark = SimBenchmark;

    }; // end window._initGame

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SIM BENCHMARK ‚Äî Compare StatEngine (fast) vs GamePipeline
    // Run from console: SimBenchmark.run() or SimBenchmark.run({gamesPerEngine: 50})
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    window.SimBenchmark = {
        /**
         * Run benchmark comparing both engines across all tiers
         * @param {Object} opts - { gamesPerEngine: 30, showModal: true }
         */
        run(opts = {}) {
            const gamesPerEngine = opts.gamesPerEngine || 30;
            const showModal = opts.showModal !== false;
            
            if (!window.gameState) {
                console.error('SimBenchmark: No gameState. Start a game first.');
                return;
            }

            const gs = window.gameState;
            const tiers = [
                { tier: 1, teams: gs.tier1Teams, label: 'Tier 1 (NBA)' },
                { tier: 2, teams: gs.tier2Teams, label: 'Tier 2 (G-League)' },
                { tier: 3, teams: gs.tier3Teams, label: 'Tier 3 (Semi-Pro)' }
            ].filter(t => t.teams && t.teams.length >= 2);

            const results = [];
            const csvRows = ['Tier,Engine,Game,HomeTeam,AwayTeam,HomeScore,AwayScore,TotalPts,HomeFGM,HomeFGA,HomeFGPct,Home3PM,Home3PA,Home3Pct,HomeFTM,HomeFTA,HomeTO,AwayFGM,AwayFGA,AwayFGPct,Away3PM,Away3PA,Away3Pct,AwayFTM,AwayFTA,AwayTO'];

            console.log(`SimBenchmark: Running ${gamesPerEngine} games √ó 2 engines √ó ${tiers.length} tiers = ${gamesPerEngine * 2 * tiers.length} total games...`);
            const startTime = performance.now();

            for (const { tier, teams, label } of tiers) {
                const fastGames = [];
                const pipeGames = [];

                for (let g = 0; g < gamesPerEngine; g++) {
                    // Pick two random teams
                    const i1 = Math.floor(Math.random() * teams.length);
                    let i2 = Math.floor(Math.random() * (teams.length - 1));
                    if (i2 >= i1) i2++;
                    const home = teams[i1];
                    const away = teams[i2];

                    // --- Fast sim (StatEngine) ---
                    const fastResult = window.StatEngine.generateGame(home, away, {
                        isPlayoffs: false, tier: tier,
                        homeCourtBonus: tier === 1 ? 3 : tier === 2 ? 2.5 : 2,
                        getFatiguePenalty: window.getFatiguePenalty || (() => 0)
                    });
                    const fHS = fastResult.homePlayerStats || [];
                    const fAS = fastResult.awayPlayerStats || [];
                    const fHome = SimBenchmark._sumTeam(fHS);
                    const fAway = SimBenchmark._sumTeam(fAS);
                    fastGames.push({ homeScore: fastResult.homeScore, awayScore: fastResult.awayScore, home: fHome, away: fAway, homeName: home.name, awayName: away.name });
                    csvRows.push(`${tier},StatEngine,${g+1},${home.name},${away.name},${fastResult.homeScore},${fastResult.awayScore},${fastResult.homeScore+fastResult.awayScore},${fHome.fgm},${fHome.fga},${fHome.fgPct},${fHome.tpm},${fHome.tpa},${fHome.tpPct},${fHome.ftm},${fHome.fta},${fHome.to},${fAway.fgm},${fAway.fga},${fAway.fgPct},${fAway.tpm},${fAway.tpa},${fAway.tpPct},${fAway.ftm},${fAway.fta},${fAway.to}`);

                    // --- Pipeline sim ---
                    const pipeResult = GamePipeline.resolve(home, away, { isPlayoffs: false, tier: tier });
                    const pHS = pipeResult.homePlayerStats || [];
                    const pAS = pipeResult.awayPlayerStats || [];
                    const pHome = SimBenchmark._sumTeam(pHS);
                    const pAway = SimBenchmark._sumTeam(pAS);
                    pipeGames.push({ homeScore: pipeResult.homeScore, awayScore: pipeResult.awayScore, home: pHome, away: pAway, homeName: home.name, awayName: away.name });
                    csvRows.push(`${tier},Pipeline,${g+1},${home.name},${away.name},${pipeResult.homeScore},${pipeResult.awayScore},${pipeResult.homeScore+pipeResult.awayScore},${pHome.fgm},${pHome.fga},${pHome.fgPct},${pHome.tpm},${pHome.tpa},${pHome.tpPct},${pHome.ftm},${pHome.fta},${pHome.to},${pAway.fgm},${pAway.fga},${pAway.fgPct},${pAway.tpm},${pAway.tpa},${pAway.tpPct},${pAway.ftm},${pAway.fta},${pAway.to}`);
                }

                results.push({
                    label, tier,
                    fast: SimBenchmark._aggregate(fastGames),
                    pipe: SimBenchmark._aggregate(pipeGames)
                });
            }

            const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
            console.log(`SimBenchmark: Complete in ${elapsed}s`);

            // Console table
            console.log('\n=== BENCHMARK RESULTS ===');
            for (const r of results) {
                console.log(`\n--- ${r.label} ---`);
                console.table({
                    'StatEngine (fast)': r.fast,
                    'Pipeline': r.pipe
                });
            }

            // Store CSV for download
            window._benchmarkCSV = csvRows.join('\n');
            window._benchmarkResults = results;
            console.log('Download CSV: SimBenchmark.downloadCSV()');
            console.log('Show modal:   SimBenchmark.showReport()');

            if (showModal) SimBenchmark.showReport();
            return results;
        },

        _sumTeam(playerStats) {
            const s = playerStats.reduce((t, p) => ({
                fgm: t.fgm + (p.fieldGoalsMade || 0), fga: t.fga + (p.fieldGoalsAttempted || 0),
                tpm: t.tpm + (p.threePointersMade || 0), tpa: t.tpa + (p.threePointersAttempted || 0),
                ftm: t.ftm + (p.freeThrowsMade || 0), fta: t.fta + (p.freeThrowsAttempted || 0),
                pts: t.pts + (p.points || 0), reb: t.reb + (p.rebounds || 0),
                ast: t.ast + (p.assists || 0), to: t.to + (p.turnovers || 0),
                stl: t.stl + (p.steals || 0), blk: t.blk + (p.blocks || 0)
            }), { fgm:0, fga:0, tpm:0, tpa:0, ftm:0, fta:0, pts:0, reb:0, ast:0, to:0, stl:0, blk:0 });
            s.fgPct = s.fga > 0 ? (s.fgm / s.fga * 100).toFixed(1) : '0.0';
            s.tpPct = s.tpa > 0 ? (s.tpm / s.tpa * 100).toFixed(1) : '0.0';
            s.ftPct = s.fta > 0 ? (s.ftm / s.fta * 100).toFixed(1) : '0.0';
            return s;
        },

        _aggregate(games) {
            const n = games.length;
            if (n === 0) return {};
            const avg = (arr) => (arr.reduce((s, v) => s + v, 0) / n).toFixed(1);
            const scores = games.map(g => g.homeScore + g.awayScore);
            const teamScores = games.flatMap(g => [g.homeScore, g.awayScore]);
            const fgPcts = games.flatMap(g => [parseFloat(g.home.fgPct), parseFloat(g.away.fgPct)]);
            const tpPcts = games.flatMap(g => [parseFloat(g.home.tpPct), parseFloat(g.away.tpPct)]);
            const ftPcts = games.flatMap(g => [parseFloat(g.home.ftPct), parseFloat(g.away.ftPct)]);
            const fgas = games.flatMap(g => [g.home.fga, g.away.fga]);
            const tpas = games.flatMap(g => [g.home.tpa, g.away.tpa]);
            const ftas = games.flatMap(g => [g.home.fta, g.away.fta]);
            const tos = games.flatMap(g => [g.home.to, g.away.to]);
            const rebs = games.flatMap(g => [g.home.reb, g.away.reb]);
            const asts = games.flatMap(g => [g.home.ast, g.away.ast]);

            return {
                'Avg Score': avg(teamScores),
                'Avg Total': avg(scores),
                'FG%': avg(fgPcts),
                '3P%': avg(tpPcts),
                'FT%': avg(ftPcts),
                'Avg FGA': avg(fgas),
                'Avg 3PA': avg(tpas),
                'Avg FTA': avg(ftas),
                'Avg TO': avg(tos),
                'Avg REB': avg(rebs),
                'Avg AST': avg(asts),
                'Min Score': Math.min(...teamScores),
                'Max Score': Math.max(...teamScores),
                'Games': n
            };
        },

        showReport() {
            const results = window._benchmarkResults;
            if (!results) { console.log('No benchmark data. Run SimBenchmark.run() first.'); return; }

            const statKeys = ['Avg Score', 'Avg Total', 'FG%', '3P%', 'FT%', 'Avg FGA', 'Avg 3PA', 'Avg FTA', 'Avg TO', 'Avg REB', 'Avg AST', 'Min Score', 'Max Score'];

            let html = `<div style="padding: 20px; max-height: 85vh; overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="margin: 0;">üî¨ Sim Benchmark Report</h2>
                    <div>
                        <button onclick="SimBenchmark.downloadCSV()" style="padding: 8px 16px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(78,205,196,0.3); color: #fff; cursor: pointer; margin-right: 8px;">üì• Download CSV</button>
                        <button onclick="document.getElementById('benchmarkModal').classList.add('hidden')" style="padding: 8px 16px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: #fff; cursor: pointer;">‚úï Close</button>
                    </div>
                </div>`;

            for (const r of results) {
                html += `<h3 style="color: #ffd700; margin: 20px 0 10px;">${r.label} (${r.fast.Games} games each)</h3>`;
                html += `<div style="overflow-x: auto;"><table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
                    <thead><tr style="border-bottom: 2px solid rgba(255,255,255,0.15);">
                        <th style="padding: 6px 10px; text-align: left;">Stat</th>
                        <th style="padding: 6px 10px; text-align: center; color: #4ecdc4;">StatEngine</th>
                        <th style="padding: 6px 10px; text-align: center; color: #ff6b6b;">Pipeline</th>
                        <th style="padding: 6px 10px; text-align: center; opacity: 0.6;">Delta</th>
                    </tr></thead><tbody>`;

                for (const key of statKeys) {
                    const fv = parseFloat(r.fast[key]) || 0;
                    const pv = parseFloat(r.pipe[key]) || 0;
                    const delta = (pv - fv).toFixed(1);
                    const deltaColor = Math.abs(pv - fv) < 2 ? 'rgba(78,205,196,0.8)' : Math.abs(pv - fv) < 5 ? 'rgba(255,215,0,0.8)' : 'rgba(255,107,107,0.8)';
                    html += `<tr style="border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <td style="padding: 5px 10px; opacity: 0.8;">${key}</td>
                        <td style="padding: 5px 10px; text-align: center; font-weight: bold;">${r.fast[key]}</td>
                        <td style="padding: 5px 10px; text-align: center; font-weight: bold;">${r.pipe[key]}</td>
                        <td style="padding: 5px 10px; text-align: center; color: ${deltaColor};">${delta > 0 ? '+' : ''}${delta}</td>
                    </tr>`;
                }
                html += '</tbody></table></div>';
            }

            html += '</div>';

            // Create or reuse benchmark modal
            let modal = document.getElementById('benchmarkModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'benchmarkModal';
                modal.className = 'modal';
                modal.style.zIndex = '1050';
                modal.innerHTML = '<div class="modal-content" style="max-width: 800px; padding: 0;"><div id="benchmarkContent"></div></div>';
                document.body.appendChild(modal);
            }
            document.getElementById('benchmarkContent').innerHTML = html;
            modal.classList.remove('hidden');
        },

        downloadCSV() {
            if (!window._benchmarkCSV) { console.log('No data. Run SimBenchmark.run() first.'); return; }
            const blob = new Blob([window._benchmarkCSV], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sim_benchmark_${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            console.log('CSV downloaded.');
        }
    };


    </script>
</body>
</html>
