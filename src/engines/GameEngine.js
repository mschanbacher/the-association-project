// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GameEngine ‚Äî Pure basketball simulation functions (no side effects)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const GameEngine = {
    /**
     * Calculate the strength of a team based on roster
     * @param {Object} team - Team object with roster
     * @returns {number} Team strength rating
     */
    calculateTeamStrength(team) {
        if (!team.roster || team.roster.length === 0) {
            console.warn(`Team ${team.name} has no roster, using base rating`);
            return team.rating;
        }
        
        // Sort players by rating (best first)
        const adjustedPlayers = [...team.roster]
            .filter(p => {
                // Filter out players who are completely unavailable
                return !p.injuryStatus || p.injuryStatus === 'healthy' || p.injuryStatus === 'day-to-day';
            })
            .filter(p => !p.resting) // Also filter out players resting due to fatigue
            .map(p => {
                let adjustedRating = p.rating;
                
                // Apply rating penalty if playing through injury
                if (p.injuryStatus === 'day-to-day' && p.injury && p.injury.ratingPenalty) {
                    adjustedRating += p.injury.ratingPenalty; // Penalty is negative
                }
                
                // Apply fatigue penalty
                const fatiguePenalty = window.getFatiguePenalty(p.fatigue || 0);
                adjustedRating += fatiguePenalty; // Penalty is negative
                
                return {
                    ...p,
                    rating: Math.max(50, adjustedRating) // Min rating 50
                };
            });
        
        if (adjustedPlayers.length === 0) {
            console.warn(`${team.name} has no available players!`);
            return 50; // Minimum team strength
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Select starters by position (matches distributeMinutes logic)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const positions = ['PG', 'SG', 'SF', 'PF', 'C'];
        const starters = [];
        const usedPlayers = new Set();
        
        positions.forEach(pos => {
            const positionPlayers = adjustedPlayers
                .filter(p => p.position === pos && !usedPlayers.has(p.id))
                .sort((a, b) => b.rating - a.rating);
            
            if (positionPlayers.length > 0) {
                starters.push(positionPlayers[0]);
                usedPlayers.add(positionPlayers[0].id);
            } else {
                // No one at this position - use best remaining
                const versatile = adjustedPlayers
                    .filter(p => !usedPlayers.has(p.id))
                    .sort((a, b) => b.rating - a.rating)[0];
                
                if (versatile) {
                    starters.push(versatile);
                    usedPlayers.add(versatile.id);
                }
            }
        });
        
        // Fill bench with remaining players by rating
        const bench = adjustedPlayers
            .filter(p => !usedPlayers.has(p.id))
            .sort((a, b) => b.rating - a.rating);
        
        // Combine rotation
        const rotation = [...starters, ...bench];
        
        // Calculate weighted average based on minutes distribution (not just top 8)
        // Weight players by their expected minutes played (matches distributeMinutes logic)
        let totalWeight = 0;
        let weightedSum = 0;
        
        // Average minutes by rotation position (1-12)
        const minutesWeights = [34, 34, 32, 30, 28, 17, 15, 12, 8, 5, 2, 1];
        
        rotation.forEach((player, index) => {
            if (index >= minutesWeights.length) return; // Beyond 12-man rotation
            
            const minutes = minutesWeights[index];
            weightedSum += player.rating * minutes;
            totalWeight += minutes;
        });
        
        const rosterStrength = weightedSum / totalWeight;
        
        // Blend roster strength (70%) with team rating (30%) for stability
        const blendedStrength = (rosterStrength * 0.7) + (team.rating * 0.3);
        
        return blendedStrength;
    },

    /**
     * Calculate chemistry bonus for a team
     * @param {Object} team - Team object
     * @param {boolean} isPlayoffs - Whether this is a playoff game
     * @returns {number} Chemistry bonus to apply
     */
    getChemistryBonus(team, isPlayoffs = false) {
        const teamChemistry = this.calculateTeamChemistry(team);
        // Formula: (chemistry - 75) / 25 * 5 = ¬±5 at extremes
        // 100 chemistry = +5, 75 = 0, 50 = -5
        let bonus = ((teamChemistry - 75) / 25) * 5;
        
        // Double impact in playoffs
        if (isPlayoffs) {
            bonus *= 2;
        }
        
        return bonus;
    },

    /**
     * Calculate team chemistry from roster
     * @param {Object} team - Team object with roster
     * @returns {number} Team chemistry score
     */
    calculateTeamChemistry(team) {
        if (!team.roster || team.roster.length === 0) {
            return 75; // Neutral chemistry
        }
        
        // Average player chemistry
        const totalChemistry = team.roster.reduce((sum, player) => {
            return sum + (player.chemistry || 75);
        }, 0);
        
        return totalChemistry / team.roster.length;
    },

    /**
     * Get home court advantage
     * @param {number} tier - Tier level
     * @returns {number} Home court advantage bonus
     */
    getHomeCourtAdvantage(tier) {
        // Simple flat bonus for now - same for all teams
        // Can be enhanced later with team-specific advantages
        return 3; // Home team gets +3 rating boost
    },

    /**
     * Calculate the outcome of a single game (PURE function - no state changes)
     * Now delegates to StatEngine for bottom-up player-stats-first simulation.
     * Returns the same interface as before PLUS homePlayerStats/awayPlayerStats.
     * @param {Object} homeTeam - Home team object
     * @param {Object} awayTeam - Away team object
     * @param {boolean} isPlayoffs - Whether this is a playoff game
     * @returns {Object} Game result with scores, winner, and player stat lines
     */
    calculateGameOutcome(homeTeam, awayTeam, isPlayoffs = false) {
        const tier = homeTeam.tier || awayTeam.tier || 1;
        return window.StatEngine.generateGame(homeTeam, awayTeam, {
            isPlayoffs: isPlayoffs,
            tier: tier,
            homeCourtBonus: this.getHomeCourtAdvantage(tier),
            getFatiguePenalty: window.getFatiguePenalty,
        });
    },

    /**
     * Calculate chemistry changes after a game (PURE function)
     * @param {Object} team - Team object
     * @param {boolean} won - Whether the team won
     * @returns {Object} Chemistry changes to apply
     */
    calculateChemistryChanges(team, won) {
        const changes = {
            playerChanges: [],
            messages: []
        };
        
        if (!team.roster) return changes;
        
        // === COLLABORATION CHEMISTRY INFLUENCE ===
        // Each player's Collaboration attribute shifts their personal chemistry per game.
        // High collab = pulls chemistry up, Low collab = drags it down.
        team.roster.forEach(player => {
            const collab = (player.attributes && player.attributes.collaboration) || 50;
            // Scale: 50 = neutral, 90 = +1.0/game, 20 = -0.8/game
            let collabDrift = (collab - 50) * 0.025;
            // Low collaborators are more toxic in losses
            if (!won && collab < 40) {
                collabDrift *= 1.5;
            }
            if (Math.abs(collabDrift) > 0.05) {
                changes.playerChanges.push({
                    playerId: player.id,
                    chemistryDelta: collabDrift,
                    reason: 'collaboration'
                });
            }
        });
        
        // Check for losing streak (5 consecutive losses)
        const losingStreak = team.currentLosingStreak || 0;
        
        if (!won) {
            const newStreak = losingStreak + 1;
            
            if (newStreak === 5) {
                // 5-game losing streak: -3 chemistry to all players
                team.roster.forEach(player => {
                    changes.playerChanges.push({
                        playerId: player.id,
                        chemistryDelta: -3,
                        reason: 'losing_streak'
                    });
                });
                changes.messages.push(`üíî ${team.name}: 5-game losing streak! Chemistry dropped by 3.`);
            }
            
            changes.losingStreak = newStreak;
        } else {
            // Win: +2 chemistry to all players
            team.roster.forEach(player => {
                changes.playerChanges.push({
                    playerId: player.id,
                    chemistryDelta: +2,
                    reason: 'win'
                });
            });
            changes.losingStreak = 0; // Reset losing streak
        }
        
        // Check for stability bonus (10 consecutive games with no roster changes)
        const gamesSinceChange = (team.gamesSinceRosterChange || 0) + 1;
        
        if (gamesSinceChange === 10) {
            // Stability bonus: +5 chemistry to all players
            team.roster.forEach(player => {
                const existing = changes.playerChanges.find(c => c.playerId === player.id);
                if (existing) {
                    existing.chemistryDelta += 5;
                } else {
                    changes.playerChanges.push({
                        playerId: player.id,
                        chemistryDelta: +5,
                        reason: 'stability'
                    });
                }
            });
            changes.messages.push(`ü§ù ${team.name}: 10 games of roster stability! Chemistry +5.`);
        }
        
        changes.gamesSinceRosterChange = gamesSinceChange;
        
        return changes;
    },

    /**
     * Calculate player development (PURE function)
     * @param {Object} player - Player object
     * @param {number} gamesPlayed - Games played this season
     * @param {number} maxGames - Max games in season
     * @returns {number} Rating change
     */
    calculatePlayerDevelopment(player, gamesPlayed, maxGames) {
        const age = player.age;
        const playingTimeRatio = gamesPlayed / maxGames; // 0.0 to 1.0
        
        // Base development potential by age
        let baseDevelopment = 0;
        
        if (age <= 21) {
            // Very young: High potential (+2 to +5)
            baseDevelopment = 2 + Math.random() * 3;
        } else if (age <= 24) {
            // Young: Good potential (+1 to +3)
            baseDevelopment = 1 + Math.random() * 2;
        } else if (age <= 27) {
            // Prime: Slight growth (0 to +2)
            baseDevelopment = Math.random() * 2;
        } else if (age <= 29) {
            // Late prime: Stable (-1 to +1)
            baseDevelopment = -1 + Math.random() * 2;
        } else if (age <= 32) {
            // Declining: Small decline (-2 to 0)
            baseDevelopment = -2 + Math.random() * 2;
        } else if (age <= 35) {
            // Late career: Moderate decline (-3 to -1)
            baseDevelopment = -3 + Math.random() * 2;
        } else {
            // Very old: Steep decline (-5 to -2)
            baseDevelopment = -5 + Math.random() * 3;
        }
        
        // Playing time modifier
        let playingTimeModifier = 1.0;
        
        if (playingTimeRatio >= 0.8) {
            playingTimeModifier = 1.0; // Starter
        } else if (playingTimeRatio >= 0.5) {
            playingTimeModifier = 0.75; // Rotation player
        } else if (playingTimeRatio >= 0.2) {
            playingTimeModifier = 0.5; // Bench player
        } else {
            playingTimeModifier = 0.25; // Rarely played
        }
        
        // Apply playing time modifier
        let finalChange = baseDevelopment * playingTimeModifier;
        
        // Add small random variance (-0.5 to +0.5)
        finalChange += (Math.random() - 0.5);
        
        // Round to integer
        return Math.round(finalChange);
    }
};
